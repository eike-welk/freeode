#!/usr/bin/env python
################################################################################
#                            Warning: Do not edit!                             #
#                                                                              #
# This file is generated, it will be overwritten every time the source file(s) #
# is/are changed.                                                              #
# If you want to change the behaviour of a simulation object                   #
# write a main routine in an other file. Use import or execfile to load        #
# the objects defined in this file into the Python interpreter.                #
################################################################################
# Generated by SIML compiler version 0.3.0 on 2007-02-12 00:20:34. 
# Source file(s): /home/eike/codedir/freeode/trunk/models/mechanical/tank.siml
################################################################################


from numpy import array, sqrt
#from scipy import *
from freeode.simulatorbase import SimulatorBase
from freeode.simulatorbase import simulatorMainFunc


class FillTank(SimulatorBase): 
    ''' 
    Object to simulate process FillTank 
    Definition in
    file: '/home/eike/codedir/freeode/trunk/models/mechanical/tank.siml'
    line: 48 
    ''' 
    
    def __init__(self): 
        super(FillTank, self).__init__() 
        self.defaultFileName = 'FillTank.simres' 
        #create all parameters with value 0; to prevent runtime errors. 
        self.p_t_Ao = 0.0 
        self.p_t_A_bott = 0.0 
        self.p_t_qIn = 0.0 
        self.p_g = 0.0 
        self.p_t_mu = 0.0 
        self.p_t_h1 = 0.0 
        self.p_solutionParameters_simulationTime = 0.0 
        self.p_solutionParameters_reportingInterval = 0.0 


    def initialize(self,  *args, **kwArgs): 
        ''' 
        Compute parameter values and 
        compute initial values of state variables 
        ''' 
        #create all variables with value 0; to prevent runtime errors.
        v_t_h = 0.0 
        v_t_qOut0 = 0.0 
        v_t_qOut1 = 0.0 
        v_t_V = 0.0 
        #create dict for parameter override 
        ovd = self._createParamOverrideDict(args, kwArgs) 
        #do computations 
        self.p_g = 9.81
        v_t_V = 0.0
        self.p_t_A_bott = 1.2
        self.p_t_Ao = 0.02
        self.p_t_h1 = 0.5
        self.p_t_mu = 0.55
        self.p_t_qIn = 0.05
        self.p_solutionParameters_simulationTime = 150.0
        self.p_solutionParameters_reportingInterval = 1.0
        
        #assemble initial values to array and store them 
        self.initialValues = array([v_t_V, ], 'float64')
        self.stateVectorLen = len(self.initialValues) 
        #put algebraic variables into array, only to compute its size 
        algVars = array([v_t_h, v_t_qOut0, v_t_qOut1, ], 'float64')
        self.algVectorLen = len(algVars) 
        #Create maping between variable names and array indices 
        self.variableNameMap = {'t.V':0, 't.h':1, 't.qOut0':2, 't.qOut1':3, }


    def dynamic(self, time, state, returnAlgVars=False): 
        ''' 
        Compute time derivative of state variables. 
        This function will be called by the solver repeatedly. 
        ''' 
        #take the state variables out of the state vector 
        v_t_V = state[0] 
        #do computations 
        v_t_h = v_t_V/self.p_t_A_bott
        v_t_qOut0 = self.p_t_mu*self.p_t_Ao*sqrt(2.0*self.p_g*v_t_h)
        if v_t_h > self.p_t_h1:
            v_t_qOut1 = self.p_t_mu*self.p_t_Ao*sqrt(2.0*self.p_g*(v_t_h - self.p_t_h1))
        else: 
            v_t_qOut1 = 0.0
        v_t_V_dt = self.p_t_qIn - v_t_qOut0 - v_t_qOut1
        
        if returnAlgVars: 
            #put algebraic variables into array 
            algVars = array([v_t_h, v_t_qOut0, v_t_qOut1, ], 'float64')
            return algVars 
        else: 
            #assemble the time derivatives into the return vector 
            stateDt = array([v_t_V_dt, ], 'float64')
            return stateDt 


    def final(self): 
        ''' 
        Display and save simulation results. 
        This function will be called once; after the simulation results 
        have been computed. 
        ''' 
        #the final method's statements 
        self.save() 
        self.graph(['t.V', 't.h', 't.qOut0', 't.qOut1', ], ) 
        print 'simulation FillTank finished.'
        




#Main function - executed when file (module) runs as an independent program.
#When file is imported into other programs, if-condition is false.
if __name__ == '__main__':
    simulatorClasses = [FillTank, ]
    simulatorMainFunc(simulatorClasses) #in module simulatorbase

