<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<?xml-stylesheet href="theme/style.css" type="text/css"?>
<head>
<!-- Generated by the Spirit (http://spirit.sf.net) QuickDoc -->
<title>VM details</title>
<link rel="stylesheet" href="theme/style.css" type="text/css"/>
<link rel="prev" href="virtual_machine.html"/>
<link rel="next" href="parser.html"/>
</head>
<body>
<table class="title" width="100%" border="0" cellspacing="2">
  <tr>
    <td>
VM details    </td>
    <td style="text-align: right;"><a href="http://spirit.sourceforge.net"><img alt="SPIRIT" src="theme/spirit.gif" ></img></a></td>
  </tr>
</table>
<table style="margin-top: 10px;">
  <tr>
    <td><a href="../index.html"><img alt="TOP" src="theme/u_arr.gif"></img></a></td>
    <td><a href="virtual_machine.html"><img alt="PREVIOUS" src="theme/l_arr.gif"></img></a></td>
    <td><a href="parser.html"><img alt="NEXT" src="theme/r_arr.gif"></img></a></td>
   </tr>
</table>
<p>
For those who prefer their descriptions to be in the form of source
code, the compilable example <a href="../src/example_vm.cpp">
here</a> should
help. It uses exactly the same code as <b>YAC</b> to implement the virtual machine, (
<a href="../src/yac_virtual_machine.hpp">
declaration</a> and
<a href="../src/yac_virtual_machine.cpp">
definition</a>), but the symbol tables and
computational stack are hard-coded rather than generated dynamically by the
parser.</p>
<p>
This example code illustrates how the virtual machine evaluates
numerical expressions similar to the one described earlier. However, it then
goes on to show:</p>
<ul><li>How new variables are added to the symbol table and how the virtual machine then assigns a value to these variables by evaluation of the stack;</li><li>How new functions are added to the symbol table, using a simple name mangling scheme to enable functions with the same name but different arity to be overloaded. The code demonstrates that dynamic redefinition of the function body is handled correctly;</li><li>That recursive user-defined functions are handled correctly.</li></ul><p>
That is, it trials the entire functionality of the virtual machine. Here, I
compile it:</p>
<pre><code>
    g++ -DDEBUG -I$HOME/boost/cvs -o example_vm example_vm.cpp </code></pre><p>
(The <tt>-DDEBUG</tt> flag causes the machine to generate diagnostic output as the
stack is evaluated.)</p>
<p>
What follows below is a description of some of the requirements that the
design addresses.</p>
<h1><a id="yac__stack"></a>yac::stack</h1><p>
The computational stack is nothing more than a collection of polymorphic nodes:</p>
<pre><code>
    <span class="keyword">namespace </span><span class="identifier">yac </span><span class="special">{

    </span><span class="keyword">struct </span><span class="identifier">node </span><span class="special">{
        </span><span class="keyword">virtual </span><span class="special">~</span><span class="identifier">node</span><span class="special">() </span><span class="special">{}
    </span><span class="special">};

    </span><span class="keyword">struct </span><span class="identifier">stack </span><span class="special">{
        </span><span class="identifier">std</span><span class="special">::</span><span class="identifier">list</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">shared_ptr</span><span class="special">&lt;</span><span class="identifier">node</span><span class="special">&gt; </span><span class="special">&gt; </span><span class="identifier">data</span><span class="special">;
    </span><span class="special">};

    </span><span class="special">} </span><span class="comment">// namespace yac
</span></code></pre>
<h2><a id="iteration"></a>Iteration</h2><p>
Whilst it is convenient to use <tt>shared_ptr</tt> to manage the data
storage, this is an implementation detail. The user is interested in a
collection of <tt>node</tt>s, so all access to the data is controlled by the
<tt>begin()</tt> and <tt>end()</tt> member functions that return
<tt>boost::indirect_iterator</tt>s to the data: Such an iterator, when dereferenced,
returns a reference to a <tt>node</tt> rather than to a <tt>shared_ptr&lt;node&gt;</tt>.</p>
<pre><code>
    <span class="keyword">class </span><span class="identifier">stack </span><span class="special">{
        </span><span class="keyword">typedef </span><span class="identifier">std</span><span class="special">::</span><span class="identifier">list</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">shared_ptr</span><span class="special">&lt;</span><span class="identifier">node</span><span class="special">&gt; </span><span class="special">&gt; </span><span class="identifier">container_t</span><span class="special">;
        </span><span class="identifier">container_t </span><span class="identifier">data</span><span class="special">;
    </span><span class="keyword">public</span><span class="special">:
        </span><span class="keyword">typedef </span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">indirect_iterator</span><span class="special">&lt;</span><span class="identifier">container_t</span><span class="special">::</span><span class="identifier">iterator</span><span class="special">&gt; </span><span class="identifier">iterator</span><span class="special">;

        </span><span class="identifier">iterator </span><span class="identifier">begin</span><span class="special">();
        </span><span class="identifier">iterator </span><span class="identifier">end</span><span class="special">();
    </span><span class="special">};
</span></code></pre>
<p>
In fact, the class goes on to wrap only those member functions of <tt>std::list</tt>
that are actually used.</p>
<h2><a id="copy_semantics"></a>Copy semantics</h2><p>
The copy semantics of
<tt>list&lt;shared_ptr&lt;node&gt; &gt;</tt> are completely different to those of the
hypothetical <tt>list&lt;node&gt;</tt>. This is unfortunate, because evaluation of
the virtual machine requires that a copy be made of the stack and that this
copy be transformed by the unwinding process. Moreover, when user-defined
functions are used, evaluation requires that the data in the copied stack be
altered to ensure that it is consistent with the symbol table of local
variables. (The ability to define recursive functions means that each
call to evaluate a user-defined function must use its own copy of any local
variables data.)</p>
<p>
In order to provide the required copy semantics, <tt>yac::stack</tt> defines a copy
constructor and assignment operators that in turn invoke the helper
function <tt>copy</tt>:</p>
<pre><code>
    <span class="keyword">struct </span><span class="identifier">node </span><span class="special">{
        </span><span class="keyword">virtual </span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">shared_ptr</span><span class="special">&lt;</span><span class="identifier">node</span><span class="special">&gt; </span><span class="identifier">clone</span><span class="special">() </span><span class="keyword">const </span><span class="special">= </span><span class="number">0</span><span class="special">;
    </span><span class="special">};

    </span><span class="keyword">void </span><span class="identifier">copy</span><span class="special">(</span><span class="identifier">stack</span><span class="special">::</span><span class="identifier">container_t </span><span class="special">&amp; </span><span class="identifier">lhs</span><span class="special">, </span><span class="identifier">stack</span><span class="special">::</span><span class="identifier">container_t </span><span class="keyword">const </span><span class="special">&amp; </span><span class="identifier">rhs</span><span class="special">)
    </span><span class="special">{
        </span><span class="identifier">lhs</span><span class="special">.</span><span class="identifier">clear</span><span class="special">();

        </span><span class="identifier">stack</span><span class="special">::</span><span class="identifier">container_t</span><span class="special">::</span><span class="identifier">const_iterator </span><span class="identifier">it </span><span class="special">= </span><span class="identifier">rhs</span><span class="special">.</span><span class="identifier">begin</span><span class="special">();
        </span><span class="identifier">stack</span><span class="special">::</span><span class="identifier">container_t</span><span class="special">::</span><span class="identifier">const_iterator </span><span class="keyword">const </span><span class="identifier">end </span><span class="special">= </span><span class="identifier">rhs</span><span class="special">.</span><span class="identifier">end</span><span class="special">();
        </span><span class="keyword">for</span><span class="special">(; </span><span class="identifier">it </span><span class="special">!= </span><span class="identifier">end</span><span class="special">; </span><span class="special">++</span><span class="identifier">it</span><span class="special">)
            </span><span class="identifier">lhs</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">((*</span><span class="identifier">it</span><span class="special">)-&gt;</span><span class="identifier">clone</span><span class="special">());
    </span><span class="special">}
</span></code></pre>
<p>
That is, <tt>copy</tt> generates a true copy of the raw data. Doing so places a
requirement on all classes deriving from <tt>node</tt> that they should implement a
<tt>clone</tt> member function that generates a copy of the data rather than
increment the <tt>shared_ptr</tt> reference count.</p>
<h2><a id="is_it_a_list_or_a_tree_"></a>Is it a list or a tree?</h2><p>
Generally speaking, the computational stack is a simple list of data and
operations. However,
<b>YAC</b> supports conditional evaluation of both <tt>a||b</tt> and <tt>a?b:c</tt> where <tt>a</tt>,
<tt>b</tt> and <tt>c</tt> can all be complicated expressions themselves. Such conditional
expressions are not well represented by a simple list, so <b>YAC</b> implements an
<tt>or_node</tt> and a <tt>branch_node</tt> that contain <tt>stack</tt> variables themselves. In
the case of <tt>or_node</tt>, the stored <tt>stack</tt> represents the expression <tt>b</tt> in
<tt>a||b</tt>. It is evaluated only if <tt>a</tt> evaluates to <tt>false</tt>. The <tt>branch_node</tt>
stores two stacks, one for <tt>b</tt> and one for <tt>c</tt> in the expression
<tt>a?b:c</tt>. Which stack is evaluated depends on the result of evaluating <tt>a</tt>.</p>
<p>
Usually, these are mere implementation details of the two node types and the
computational stack should be regarded as a simple list. An
exception to this rule does exist, however. If the user defines a recursive
function such as:</p>
<pre><code>
    factorial(x) = (x &lt; 0.01) ? 1 : x * factorial(x - 1) </code></pre><p>
then evaluation of, say, <tt>factorial(2)</tt> will require evaluations of
<tt>factorial(1)</tt> and <tt>factorial(0)</tt> also. All three function calls should have
separate symbol tables for the local variable <tt>x</tt> and so the stack
representation of <tt>(x&lt;0.01)?1:x*factorial(x-1)</tt> that is copied for
each evaluation should be modified so that references to <tt>x</tt> point to the
correct data. Perhaps some code<a id="perhaps_some_code"></a> will make this clearer:</p>
<pre><code>
    <span class="comment">// params contains the argument list to be passed to the function
    </span><span class="keyword">double </span><span class="identifier">user_function</span><span class="special">::</span><span class="identifier">eval_priv</span><span class="special">(</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt; </span><span class="keyword">const </span><span class="special">&amp; </span><span class="identifier">params</span><span class="special">) </span><span class="keyword">const
    </span><span class="special">{
        </span><span class="identifier">BOOST_ASSERT</span><span class="special">(</span><span class="identifier">arg_names_</span><span class="special">.</span><span class="identifier">size</span><span class="special">() </span><span class="special">== </span><span class="identifier">arity_</span><span class="special">);

        </span><span class="comment">// Create a copy of the local variables symbol table.
        </span><span class="identifier">symbol_table_t </span><span class="identifier">local_vars_copy </span><span class="special">= </span><span class="identifier">local_vars_</span><span class="special">;

        </span><span class="comment">// Assign values to the elements of this symbol table
        // using the argument list data stored in params.
        </span><span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t </span><span class="keyword">const </span><span class="identifier">size </span><span class="special">= </span><span class="identifier">arg_names_</span><span class="special">.</span><span class="identifier">size</span><span class="special">();
        </span><span class="keyword">for </span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t </span><span class="identifier">i </span><span class="special">= </span><span class="number">0</span><span class="special">; </span><span class="identifier">i </span><span class="special">!= </span><span class="identifier">size</span><span class="special">; </span><span class="special">++</span><span class="identifier">i</span><span class="special">) </span><span class="special">{
            </span><span class="keyword">double </span><span class="special">* </span><span class="keyword">const </span><span class="identifier">ptr </span><span class="special">= </span><span class="identifier">find</span><span class="special">(</span><span class="identifier">local_vars_copy</span><span class="special">, </span><span class="identifier">arg_names_</span><span class="special">[</span><span class="identifier">i</span><span class="special">].</span><span class="identifier">c_str</span><span class="special">());
            </span><span class="identifier">BOOST_ASSERT</span><span class="special">(</span><span class="identifier">ptr</span><span class="special">);
            </span><span class="special">*</span><span class="identifier">ptr </span><span class="special">= </span><span class="identifier">params</span><span class="special">[</span><span class="identifier">i</span><span class="special">];
        </span><span class="special">}

        </span><span class="comment">// Ensure that the variable_nodes in stk_copy point to
        // the appropriate entry in local_vars_copy (rather than
        // those of local_vars_).
        </span><span class="identifier">stack </span><span class="identifier">stk_copy </span><span class="special">= </span><span class="identifier">stk_</span><span class="special">;
        </span><span class="identifier">update_stack</span><span class="special">(</span><span class="identifier">stk_copy</span><span class="special">, </span><span class="identifier">local_vars_copy</span><span class="special">, </span><span class="identifier">local_vars_</span><span class="special">, </span><span class="identifier">arg_names_</span><span class="special">);

        </span><span class="comment">// Evaluate the stack.
        </span><span class="keyword">return </span><span class="identifier">evaluate</span><span class="special">(</span><span class="identifier">stk_copy</span><span class="special">);
    </span><span class="special">}
</span></code></pre>
<p>
It is the <tt>update_stack</tt> function only that requires a mechanism
to iterate over the stored stacks of any <tt>or_node</tt>s and <tt>branch_node</tt>s in
<tt>stk_copy</tt>. The implementation is trivially simple, using <tt>nbranches</tt> and
<tt>branch</tt> virtual functions to access these stacks:</p>
<pre><code>
    <span class="keyword">struct </span><span class="identifier">node </span><span class="special">{
        </span><span class="keyword">virtual </span><span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t </span><span class="identifier">nbranches</span><span class="special">() </span><span class="keyword">const </span><span class="special">{ </span><span class="keyword">return </span><span class="number">0</span><span class="special">; </span><span class="special">}
        </span><span class="keyword">virtual </span><span class="identifier">stack </span><span class="special">* </span><span class="identifier">branch</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span><span class="special">) </span><span class="special">{ </span><span class="keyword">return </span><span class="number">0</span><span class="special">; </span><span class="special">}
    </span><span class="special">};

    </span><span class="keyword">struct </span><span class="identifier">function_node </span><span class="special">: </span><span class="keyword">public </span><span class="identifier">node </span><span class="special">{...};

    </span><span class="keyword">struct </span><span class="identifier">or_node </span><span class="special">: </span><span class="keyword">public </span><span class="identifier">function_node </span><span class="special">{
        </span><span class="identifier">or_node</span><span class="special">(</span><span class="identifier">stack </span><span class="keyword">const </span><span class="special">&amp; </span><span class="identifier">stk</span><span class="special">);

        </span><span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t </span><span class="identifier">nbranches</span><span class="special">() </span><span class="keyword">const </span><span class="special">{ </span><span class="keyword">return </span><span class="number">1</span><span class="special">; </span><span class="special">}
        </span><span class="identifier">stack </span><span class="special">* </span><span class="identifier">branch</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t </span><span class="identifier">i</span><span class="special">) </span><span class="special">{ </span><span class="keyword">return </span><span class="identifier">i </span><span class="special">== </span><span class="number">0 </span><span class="special">? </span><span class="special">&amp;</span><span class="identifier">rhs_stk_ </span><span class="special">: </span><span class="number">0</span><span class="special">; </span><span class="special">}
    </span><span class="keyword">private</span><span class="special">:
        </span><span class="identifier">stack </span><span class="identifier">rhs_stk_</span><span class="special">;
    </span><span class="special">};

    </span><span class="keyword">struct </span><span class="identifier">branch_node </span><span class="special">: </span><span class="keyword">public </span><span class="identifier">function_node </span><span class="special">{
        </span><span class="identifier">branch_node</span><span class="special">(</span><span class="identifier">stack </span><span class="keyword">const </span><span class="special">&amp; </span><span class="identifier">stk1</span><span class="special">, </span><span class="identifier">stack </span><span class="keyword">const </span><span class="special">&amp; </span><span class="identifier">stk2</span><span class="special">);

        </span><span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t </span><span class="identifier">nbranches</span><span class="special">() </span><span class="keyword">const </span><span class="special">{ </span><span class="keyword">return </span><span class="number">2</span><span class="special">; </span><span class="special">}
        </span><span class="identifier">stack </span><span class="special">* </span><span class="identifier">branch</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t </span><span class="identifier">i</span><span class="special">)
            </span><span class="special">{ </span><span class="keyword">return </span><span class="special">(</span><span class="identifier">i </span><span class="special">&gt; </span><span class="number">1</span><span class="special">) </span><span class="special">? </span><span class="number">0 </span><span class="special">: </span><span class="special">(</span><span class="identifier">i </span><span class="special">== </span><span class="number">0 </span><span class="special">? </span><span class="special">&amp;</span><span class="identifier">stk1_ </span><span class="special">: </span><span class="special">&amp;</span><span class="identifier">stk2_</span><span class="special">); </span><span class="special">}
    </span><span class="keyword">private</span><span class="special">:
        </span><span class="identifier">stack </span><span class="identifier">stk1_</span><span class="special">, </span><span class="identifier">stk2_</span><span class="special">;
    </span><span class="special">};
</span></code></pre>
<h1><a id="the_various_node_types"></a>The various node types</h1><p>
There are five primary node types visible to the <tt>evaluate</tt> function:
<tt>number_node</tt> and <tt>function_node</tt> together represent the numeric expressions
defined by the expression grammar. Evaluation of such an expressions proceeds
in a manner identical to that described
<a href="virtual_machine.html#how_it_works">
earlier</a>. <tt>print_node</tt> simply outputs the
evaluated expression to stdout. <tt>variable_node</tt> will assign the result of such
an  expression to an element of one of the variable symbol
tables. <tt>func_def_node</tt> will assign a <tt>user_func_expression</tt> variable to an
element in the functions symbol table. Almost all other node classes are
specializations of <tt>function_node</tt>.</p>
<table style="margin-top: 10px;">
  <tr>
    <td><a href="../index.html"><img alt="TOP" src="theme/u_arr.gif"></img></a></td>
    <td><a href="virtual_machine.html"><img alt="PREVIOUS" src="theme/l_arr.gif"></img></a></td>
    <td><a href="parser.html"><img alt="NEXT" src="theme/r_arr.gif"></img></a></td>
   </tr>
</table>
<hr/>
<p>
  <a href="http://validator.w3.org/check/referer">
    <img style="border:0;width:88px;height:31px"
      src="theme/valid-xhtml11.png"
      alt="Valid XHTML 1.1!" />
  </a>
  <a href="http://jigsaw.w3.org/css-validator/check/referer">
    <img style="border:0;width:88px;height:31px"
      src="theme/vcss.png"
      alt="Valid CSS!" />
  </a>
</p>
<p class="copyright">

  Copyright &copy; 2004 Angus Leeming<br/><br/>
  Distributed under the Boost Software License,
  Version 1.0. (See accompanying file
  <a href="../LICENSE_1_0.txt">LICENSE_1_0.txt</a> or copy at
  <a href="http://www.boost.org/LICENSE_1_0.txt">
     http://www.boost.org/LICENSE_1_0.txt
  </a>)

</p>
</body>
</html>
