<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<?xml-stylesheet href="theme/style.css" type="text/css"?>
<head>
<!-- Generated by the Spirit (http://spirit.sf.net) QuickDoc -->
<title>variable_grammar</title>
<link rel="stylesheet" href="theme/style.css" type="text/css"/>
<link rel="prev" href="parser.html"/>
<link rel="next" href="function_grammar.html"/>
</head>
<body>
<table class="title" width="100%" border="0" cellspacing="2">
  <tr>
    <td>
variable_grammar    </td>
    <td style="text-align: right;"><a href="http://spirit.sourceforge.net"><img alt="SPIRIT" src="theme/spirit.gif" ></img></a></td>
  </tr>
</table>
<table style="margin-top: 10px;">
  <tr>
    <td><a href="../index.html"><img alt="TOP" src="theme/u_arr.gif"></img></a></td>
    <td><a href="parser.html"><img alt="PREVIOUS" src="theme/l_arr.gif"></img></a></td>
    <td><a href="function_grammar.html"><img alt="NEXT" src="theme/r_arr.gif"></img></a></td>
   </tr>
</table>
<p>
Consider what happens when the parser encounters a variable
declaration such as <tt>x=2</tt>. Using <a href="http://spirit.sourceforge.net">
Spirit</a>, the parser for this
statement can be written as:</p>
<pre><code>
    <span class="identifier">spirit</span><span class="special">::</span><span class="identifier">rule</span><span class="special">&lt;</span><span class="identifier">ScannerT</span><span class="special">&gt; </span><span class="identifier">var_assignment</span><span class="special">;
    </span><span class="identifier">expression_grammar </span><span class="identifier">expression</span><span class="special">;
    </span><span class="identifier">name_grammar </span><span class="identifier">name</span><span class="special">;

    </span><span class="identifier">var_assign </span><span class="special">= </span><span class="identifier">name </span><span class="special">&gt;&gt; </span><span class="literal">'=' </span><span class="special">&gt;&gt; </span><span class="identifier">expression</span><span class="special">;
</span></code></pre>
<p>
Having parsed this statement, the code should do two things:</p>
<ul><li>update the table of global variables so that subsequent expressions understand that <tt>x</tt> is a variable.</li><li>generate a <tt>stack</tt> representation of the string <tt>x=2</tt>:</li></ul><pre><code>
    0    variable_node     x
    1    const_value_node  2
    2    assign_node </code></pre><h1><a id="public_interface_of_expression_grammar_"></a>Public interface of expression_grammar </h1><p>
In order for <tt>expression_grammar</tt> to parse an expression
successfully, it must have access to lists of all existing variables and
functions. If successful, it should make available a <tt>stack</tt>
representation of the data. If we use closures, then 'make available'
becomes 'return'. The grammar's public interface follows naturally:</p>
<pre><code>
    <span class="keyword">using </span><span class="keyword">namespace </span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">spirit</span><span class="special">;
    </span><span class="keyword">using </span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">shared_ptr</span><span class="special">;

    </span><span class="keyword">namespace </span><span class="identifier">yac </span><span class="special">{

    </span><span class="keyword">struct </span><span class="identifier">stack_closure </span><span class="special">: </span><span class="identifier">closure</span><span class="special">&lt;</span><span class="identifier">stack_closure</span><span class="special">, </span><span class="identifier">stack</span><span class="special">&gt;
    </span><span class="special">{
        </span><span class="identifier">member1 </span><span class="identifier">stk</span><span class="special">;
    </span><span class="special">};

    </span><span class="keyword">struct </span><span class="identifier">expression_grammar
        </span><span class="special">: </span><span class="identifier">spirit</span><span class="special">::</span><span class="identifier">grammar</span><span class="special">&lt;</span><span class="identifier">expression_grammar</span><span class="special">, </span><span class="identifier">stack_closure</span><span class="special">::</span><span class="identifier">context_t</span><span class="special">&gt;
    </span><span class="special">{
        </span><span class="keyword">typedef </span><span class="identifier">spirit</span><span class="special">::</span><span class="identifier">symbols</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">shared_ptr</span><span class="special">&lt;</span><span class="identifier">function</span><span class="special">&gt; </span><span class="special">&gt; </span><span class="identifier">function_table_t</span><span class="special">;
        </span><span class="keyword">typedef </span><span class="identifier">spirit</span><span class="special">::</span><span class="identifier">symbols</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt; </span><span class="identifier">var_table_t</span><span class="special">;

        </span><span class="identifier">function_table_t </span><span class="keyword">const </span><span class="special">&amp; </span><span class="identifier">functions</span><span class="special">;
        </span><span class="identifier">var_table_t </span><span class="keyword">const </span><span class="special">&amp; </span><span class="identifier">global_vars</span><span class="special">;

        </span><span class="identifier">expression_grammar</span><span class="special">(</span><span class="identifier">function_table_t </span><span class="keyword">const </span><span class="special">&amp; </span><span class="identifier">funcs</span><span class="special">,
                           </span><span class="identifier">var_table_t </span><span class="keyword">const </span><span class="special">&amp; </span><span class="identifier">gvars</span><span class="special">)
            </span><span class="special">: </span><span class="identifier">functions</span><span class="special">(</span><span class="identifier">funcs</span><span class="special">), </span><span class="identifier">global_vars</span><span class="special">(</span><span class="identifier">gvars</span><span class="special">)
        </span><span class="special">{}
    </span><span class="special">};

    </span><span class="special">} </span><span class="comment">// namespace yac
</span></code></pre>
<p>
That is, the grammar receives <tt>const</tt> references to symbols tables
for both functions and variables. These tables are not altered during
the parsing of the expression but are used to ascertain whether a
given symbol is allowable.</p>
<p>
In fact, the code above does not tell quite the whole story;
<tt>expression_grammar</tt> has a second constructor also that takes an additional
<tt>var_table_t</tt> reference. This second constructor is used when parsing a
function body, the second <tt>var_table_t</tt> parameter being a symbol table of
variables local to the function.</p>
<h1><a id="public_interface_of_name_grammar"></a>Public interface of name_grammar</h1><p>
<b>YAC</b> variable and function names must conform to the same naming rules, so
<tt>name_grammar</tt> will be used by both. The semantic actions that are performed
by the variable and function parsers are, however, rather different.</p>
<p>
In the case in question, the <tt>name_grammar</tt> variable <tt>name</tt> will be
used to update the <tt>global_vars</tt> symbol table that is accessed by the
<tt>expression_grammar</tt> variable <tt>expression</tt>. However, the symbol
table should <i>not</i> be updated until <i>after</i> <tt>expression</tt> itself is
parsed. Otherwise definitions such as <tt>x = x + 1</tt> would be legal. (OK
as an assignment but not as the original declaration of <tt>x</tt>.)</p>
<p>
This contrasts with the behaviour of the function_grammar which should
add a function name to the symbol table of available functions
<i>before</i> attempting to parse the defining <tt>expression</tt>. (To enable
recursive functions to be defined.)</p>
<p>
Clearly, therefore, these semantic actions should not be factored into
the <tt>name_grammar</tt> class itself. It's public interface is, therefore,
trivial:</p>
<pre><code>
    <span class="keyword">struct </span><span class="identifier">name_grammar </span><span class="special">: </span><span class="identifier">spirit</span><span class="special">::</span><span class="identifier">grammar</span><span class="special">&lt;</span><span class="identifier">name_grammar</span><span class="special">&gt;
    </span><span class="special">{
        </span><span class="identifier">name_grammar</span><span class="special">() </span><span class="special">{}
    </span><span class="special">};
</span></code></pre>
<p>
<a href="http://spirit.sourceforge.net">
Spirit</a> will return a pair of iterators to the beginning and end of the
variable or function name. Thereafter, it's up to the parent grammar to
use these data appropriately.</p>
<h1><a id="public_interface_of_variable_grammar"></a>Public interface of variable_grammar</h1><p>
The public interface of the <tt>variable_grammar</tt> class should fulfill the
requirements outlined at the top of this page. It should 'return'
a <tt>stack</tt> wrapped up as a <tt>closure</tt>. It's constructor should
receive a <tt>non-const</tt> reference to the global variables symbol
table. Finally, this same constructor should also receive a <tt>const</tt>
reference to the functions symbol table to enable the grammar to parse
<tt>expression</tt>:</p>
<pre><code>
    <span class="keyword">using </span><span class="keyword">namespace </span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">spirit</span><span class="special">;
    </span><span class="keyword">using </span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">shared_ptr</span><span class="special">;

    </span><span class="keyword">namespace </span><span class="identifier">yac </span><span class="special">{

    </span><span class="keyword">struct </span><span class="identifier">stack_closure </span><span class="special">: </span><span class="identifier">closure</span><span class="special">&lt;</span><span class="identifier">stack_closure</span><span class="special">, </span><span class="identifier">stack</span><span class="special">&gt;
    </span><span class="special">{
        </span><span class="identifier">member1 </span><span class="identifier">stk</span><span class="special">;
    </span><span class="special">};

    </span><span class="keyword">struct </span><span class="identifier">variable_grammar
        </span><span class="special">: </span><span class="identifier">grammar</span><span class="special">&lt;</span><span class="identifier">variable_grammar</span><span class="special">, </span><span class="identifier">stack_closure</span><span class="special">::</span><span class="identifier">context_t</span><span class="special">&gt;
    </span><span class="special">{
        </span><span class="keyword">typedef </span><span class="identifier">symbols</span><span class="special">&lt;</span><span class="identifier">shared_ptr</span><span class="special">&lt;</span><span class="identifier">function_node</span><span class="special">&gt; </span><span class="special">&gt; </span><span class="identifier">function_table_t</span><span class="special">;
        </span><span class="keyword">typedef </span><span class="identifier">symbols</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt; </span><span class="identifier">var_table_t</span><span class="special">;

        </span><span class="identifier">function_table_t </span><span class="keyword">const </span><span class="special">&amp; </span><span class="identifier">functions</span><span class="special">;
        </span><span class="identifier">var_table_t </span><span class="special">&amp; </span><span class="identifier">vars</span><span class="special">;

        </span><span class="identifier">variable_grammar</span><span class="special">(</span><span class="identifier">function_table_t </span><span class="keyword">const </span><span class="special">&amp; </span><span class="identifier">f</span><span class="special">, </span><span class="identifier">var_table_t </span><span class="special">&amp; </span><span class="identifier">v</span><span class="special">)
            </span><span class="special">: </span><span class="identifier">functions</span><span class="special">(</span><span class="identifier">f</span><span class="special">), </span><span class="identifier">vars</span><span class="special">(</span><span class="identifier">v</span><span class="special">)
        </span><span class="special">{}

        </span><span class="keyword">template </span><span class="special">&lt;</span><span class="keyword">typename </span><span class="identifier">ScannerT</span><span class="special">&gt;
        </span><span class="keyword">struct </span><span class="identifier">definition</span><span class="special">;
    </span><span class="special">};

    </span><span class="special">} </span><span class="comment">// namespace yac
</span></code></pre>
<h1><a id="variable_grammar__definition"></a>variable_grammar::definition</h1><p>
We know that <tt>variable_grammar::definition</tt> will use <tt>name_grammar</tt>
and <tt>expression_grammar</tt> variables to parse the input data and we
know what arguments these grammars' constructors require:</p>
<pre><code>
    <span class="keyword">template </span><span class="special">&lt;</span><span class="keyword">typename </span><span class="identifier">ScannerT</span><span class="special">&gt;
    </span><span class="keyword">struct </span><span class="identifier">definition
    </span><span class="special">{
        </span><span class="identifier">definition</span><span class="special">(</span><span class="identifier">variable_grammar </span><span class="keyword">const </span><span class="special">&amp; </span><span class="identifier">self</span><span class="special">)
            </span><span class="special">: </span><span class="identifier">name</span><span class="special">(</span><span class="identifier">self</span><span class="special">.</span><span class="identifier">vars</span><span class="special">),
              </span><span class="identifier">expression</span><span class="special">(</span><span class="identifier">self</span><span class="special">.</span><span class="identifier">functions</span><span class="special">, </span><span class="identifier">self</span><span class="special">.</span><span class="identifier">vars</span><span class="special">)
        </span><span class="special">{
            </span><span class="special">...
        </span><span class="special">}
    </span><span class="keyword">private</span><span class="special">:
        </span><span class="identifier">name_grammar </span><span class="identifier">name</span><span class="special">;
        </span><span class="identifier">expression_grammar </span><span class="identifier">expression</span><span class="special">;
    </span><span class="special">};
</span></code></pre>
<p>
Two sets of semantic actions should be invoked when parsing a variable
declaration. First, the parsed data should be stored
locally. Thereafter, the global symbol tables and expression stack
should be updated. The first step is encoded quite simply:</p>
<pre><code>
    <span class="keyword">namespace </span><span class="identifier">yac </span><span class="special">{

    </span><span class="keyword">struct </span><span class="identifier">var_closure
        </span><span class="special">: </span><span class="identifier">spirit</span><span class="special">::</span><span class="identifier">closure</span><span class="special">&lt;</span><span class="identifier">var_closure</span><span class="special">, </span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">, </span><span class="identifier">stack</span><span class="special">&gt;
    </span><span class="special">{
        </span><span class="identifier">member1 </span><span class="identifier">name</span><span class="special">;
        </span><span class="identifier">member2 </span><span class="identifier">stk</span><span class="special">;
    </span><span class="special">};

    </span><span class="keyword">typename </span><span class="identifier">spirit</span><span class="special">::</span><span class="identifier">rule</span><span class="special">&lt;</span><span class="identifier">scanner_t</span><span class="special">, </span><span class="identifier">var_closure</span><span class="special">::</span><span class="identifier">context_t</span><span class="special">&gt; </span><span class="identifier">step1</span><span class="special">;
    </span><span class="keyword">typename </span><span class="identifier">spirit</span><span class="special">::</span><span class="identifier">rule</span><span class="special">&lt;</span><span class="identifier">ScannerT</span><span class="special">&gt; </span><span class="identifier">step2</span><span class="special">;

    </span><span class="special">...
    </span><span class="identifier">step2
       </span><span class="special">= </span><span class="identifier">step1
         </span><span class="special">[
             </span><span class="comment">// semantic actions to fill the
             // world-visible data structures.
         </span><span class="special">]
       </span><span class="special">;

    </span><span class="identifier">step1
        </span><span class="special">=  </span><span class="identifier">name
           </span><span class="special">[
               </span><span class="identifier">step2</span><span class="special">.</span><span class="identifier">name </span><span class="special">= </span><span class="identifier">construct_</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;(</span><span class="identifier">arg1</span><span class="special">, </span><span class="identifier">arg2</span><span class="special">)
           </span><span class="special">]
        </span><span class="special">&gt;&gt; </span><span class="literal">'='
        </span><span class="special">&gt;&gt; </span><span class="identifier">expression
           </span><span class="special">[
               </span><span class="identifier">step2</span><span class="special">.</span><span class="identifier">stk </span><span class="special">= </span><span class="identifier">arg1
           </span><span class="special">]
        </span><span class="special">;
</span></code></pre>
<p>
This code snippet is a perfect example of Phoenix's lambda facilities
in action. They can lead to extremely clear code. Note, however, that
the semantic actions attached to <tt>step1</tt> are updating the closure variables
attached to step2. The code was split into <tt>step1</tt> and <tt>step2</tt>
simply to ease readability. There are no problems with doing so
because this grammar is not recursive. If it were, then the closures
would have to be attached to <tt>step1</tt> and these data would then be
<i>returned</i> to <tt>step2</tt>. Note, however, that it is the <tt>member1</tt>
closure variable that is returned in such cases, so we would need a
compound data structure to store the data. In fact, it would be simpler
to attach <i>all</i> the semantic actions to the <tt>step1</tt> rule, discarding
<tt>step2</tt> entirely.</p>
<p>
Having generated the local data stores, the  second stage of the
process is to use this stored data to update the global variables
symbol table <tt>self.global_vars</tt> and the closure <tt>self.stk</tt> that is
'returned' by the <tt>variable_grammar</tt>:</p>
<pre><code>
    <span class="keyword">using </span><span class="identifier">phoenix</span><span class="special">::</span><span class="identifier">arg1</span><span class="special">;
    </span><span class="keyword">using </span><span class="identifier">phoenix</span><span class="special">::</span><span class="identifier">if_</span><span class="special">;
    </span><span class="keyword">using </span><span class="identifier">phoenix</span><span class="special">::</span><span class="identifier">var</span><span class="special">;

    </span><span class="identifier">step2
        </span><span class="special">= </span><span class="identifier">step1
          </span><span class="special">[
              </span><span class="identifier">if_</span><span class="special">(!</span><span class="identifier">find_symbol</span><span class="special">(</span><span class="identifier">var</span><span class="special">(</span><span class="identifier">self</span><span class="special">.</span><span class="identifier">vars</span><span class="special">), </span><span class="identifier">step2</span><span class="special">.</span><span class="identifier">name</span><span class="special">))
              </span><span class="special">[
                  </span><span class="identifier">add_symbol</span><span class="special">(</span><span class="identifier">var</span><span class="special">(</span><span class="identifier">self</span><span class="special">.</span><span class="identifier">vars</span><span class="special">), </span><span class="identifier">step2</span><span class="special">.</span><span class="identifier">name</span><span class="special">)
              </span><span class="special">]
          </span><span class="special">]
          </span><span class="special">[
              </span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">self</span><span class="special">.</span><span class="identifier">stk</span><span class="special">, </span><span class="identifier">find_symbol</span><span class="special">(</span><span class="identifier">var</span><span class="special">(</span><span class="identifier">self</span><span class="special">.</span><span class="identifier">vars</span><span class="special">),
                                              </span><span class="identifier">step2</span><span class="special">.</span><span class="identifier">name</span><span class="special">)),
              </span><span class="identifier">self</span><span class="special">.</span><span class="identifier">stk </span><span class="special">+= </span><span class="identifier">step2</span><span class="special">.</span><span class="identifier">stk</span><span class="special">,
              </span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">self</span><span class="special">.</span><span class="identifier">stk</span><span class="special">, </span><span class="identifier">new_</span><span class="special">&lt;</span><span class="identifier">assign_node</span><span class="special">&gt;())
          </span><span class="special">]
        </span><span class="special">;
</span></code></pre>
<p>
Whoaa! What's going on here?</p>
<p>
The first semantic action,
<tt>if_(!var(name_return.already_present)) [...]</tt>,
is an example of a Phoenix lazy statement. If the symbol is not
already present in <tt>self.global_vars</tt> then we add it. <tt>find_symbol</tt> and
<tt>add_symbol</tt> are  &#8212;  you've guessed it  &#8212;  lazy functions invoking
<tt>spirit::symbols::find</tt> and <tt>spirit::symbols::add</tt>, respectively. The
difference is that we wrote these lazy functions ourselves.</p>
<p>
Writing a lazy function is as easy as:</p>
<pre><code>
    <span class="keyword">struct </span><span class="identifier">add_symbol_impl </span><span class="special">{
        </span><span class="keyword">template </span><span class="special">&lt;</span><span class="keyword">typename </span><span class="identifier">T</span><span class="special">, </span><span class="keyword">typename </span><span class="identifier">Arg</span><span class="special">&gt;
        </span><span class="keyword">struct </span><span class="identifier">result
        </span><span class="special">{
            </span><span class="keyword">typedef </span><span class="keyword">void </span><span class="identifier">type</span><span class="special">;
        </span><span class="special">};

        </span><span class="keyword">template </span><span class="special">&lt;</span><span class="keyword">typename </span><span class="identifier">SymbolT</span><span class="special">&gt;
        </span><span class="keyword">void </span><span class="keyword">operator</span><span class="special">()(</span><span class="identifier">SymbolT </span><span class="special">&amp; </span><span class="identifier">symbols</span><span class="special">, </span><span class="identifier">string </span><span class="keyword">const </span><span class="special">&amp; </span><span class="identifier">str</span><span class="special">) </span><span class="keyword">const
        </span><span class="special">{
            </span><span class="identifier">symbols</span><span class="special">.</span><span class="identifier">add</span><span class="special">(</span><span class="identifier">str</span><span class="special">.</span><span class="identifier">c_str</span><span class="special">());
        </span><span class="special">}
    </span><span class="special">};

    </span><span class="identifier">phoenix</span><span class="special">::</span><span class="identifier">function</span><span class="special">&lt;</span><span class="identifier">add_symbol_impl</span><span class="special">&gt; </span><span class="keyword">const
        </span><span class="identifier">add_symbol </span><span class="special">= </span><span class="identifier">add_symbol_impl</span><span class="special">();
</span></code></pre>
<p>
That is, the <tt>phoenix::function&lt;&gt;</tt> instance wraps a struct that contains
a nested <tt>result</tt> class template and a template <tt>operator()</tt> that
invokes the desired member function/variable. In this case, we're not
interested in chaining multiple <tt>add</tt>s together so <tt>result::type</tt>
is a <tt>typedef</tt> for <tt>void</tt>. Note that the <tt>result</tt> template has the
same number of template parameters as the <tt>operator()</tt> has
arguments, here two. The lazy functions specific to <b>YAC</b> can be found
<a href="../src/yac_lazy_functions.hpp">
here</a>.</p>
<p>
Having ensured that the <tt>vars</tt> symbol table contains the
just-parsed symbol, we're now in a position to construct the <tt>self.stk</tt>
closure 'returned' by <tt>variable_grammar</tt>. The lazy functions
<tt>push_back</tt> and <tt>find_symbol</tt> wrap <tt>stack::push_back</tt>
and <tt>spirit::symbols::find</tt>, respectively. <tt>+=</tt> is a lazy operator
invoking <tt>stack::operator+=</tt> and <tt>new_</tt> is Phoenix's lazy function wrapper
for <tt>operator new</tt>  &#8212;  more on this later.</p>
<p>
The actual code for <tt>variable_grammar</tt> can be found
<a href="../src/yac_variable_grammar.hpp">
here</a>. I won't try and convince you
that this example has been anything less than complicated. I would
say, however, that it is trying to do something that is itself
complicated. It is my belief that <a href="http://spirit.sourceforge.net">
Spirit</a> and Phoenix have enabled me
to do so in a transparent manner. I can only hope that you believe so too.</p>
<table style="margin-top: 10px;">
  <tr>
    <td><a href="../index.html"><img alt="TOP" src="theme/u_arr.gif"></img></a></td>
    <td><a href="parser.html"><img alt="PREVIOUS" src="theme/l_arr.gif"></img></a></td>
    <td><a href="function_grammar.html"><img alt="NEXT" src="theme/r_arr.gif"></img></a></td>
   </tr>
</table>
<hr/>
<p>
  <a href="http://validator.w3.org/check/referer">
    <img style="border:0;width:88px;height:31px"
      src="theme/valid-xhtml11.png"
      alt="Valid XHTML 1.1!" />
  </a>
  <a href="http://jigsaw.w3.org/css-validator/check/referer">
    <img style="border:0;width:88px;height:31px"
      src="theme/vcss.png"
      alt="Valid CSS!" />
  </a>
</p>
<p class="copyright">

  Copyright &copy; 2004 Angus Leeming<br/><br/>
  Distributed under the Boost Software License,
  Version 1.0. (See accompanying file
  <a href="../LICENSE_1_0.txt">LICENSE_1_0.txt</a> or copy at
  <a href="http://www.boost.org/LICENSE_1_0.txt">
     http://www.boost.org/LICENSE_1_0.txt
  </a>)

</p>
</body>
</html>
