//This file was generated by the script "py2c_string".

"\n"
"\n"
"from scipy import * # Also includes Numeric.\n"
"import Gnuplot, Gnuplot.funcutils # @todo switch to a more well known graphics library\n"
"\n"
"\n"
"class SimulatorBase:\n"
"    \"\"\" Base class for the generated simulator classes \"\"\"\n"
"\n"
"    def __init__(self):\n"
"##        #Store if initial values have been computed\n"
"##        self._initialValuesDirty = True\n"
"        pass\n"
"        \n"
"    def help(self):\n"
"        \"\"\"Show a (this) help text.\"\"\"\n"
"        help(self.__class__)\n"
"\n"
"    def helpVariables(self):\n"
"        \"\"\"Show list of all variables.\"\"\"\n"
"##        print \"Variables of this simulation object:\"\n"
"        for i in self._resultArrayMap: \n"
"            print \"'%s', \" % i,\n"
"        print\n"
"    \n"
"    def clear(self):\n"
"        \"\"\"\n"
"        Delete the results. Use prior to simulateSteadyState().\n"
"        \"\"\"\n"
"        if hasattr(self, 'time'):\n"
"            del self.time\n"
"        if hasattr(self, '_resultArray'):\n"
"            del self._resultArray\n"
"\n"
"    def get(self, varName):\n"
"        \"\"\"\n"
"        Get a variable by name.\n"
"        \n"
"        The funcion returns a vector with the variable's values at all \n"
"        simulated points in time. Parameter values can not be accessed by \n"
"        this function.\n"
"        Parameter:\n"
"        varName:    Text string with the variable name as it would appear in \n"
"                    the Siml language.\n"
"                    There are special variable names:\n"
"                        'time': vector of simulated points in time\n"
"                        'all': array of all variables\n"
"        Example:\n"
"            >>> mySimulationObject.get('r.X')        \n"
"        \"\"\"\n"
"        if varName == 'time':\n"
"            return self.time\n"
"        elif varName == 'all':\n"
"            return self._resultArray\n"
"        index = self._resultArrayMap[varName]\n"
"        return self._resultArray[:,index]\n"
"\n"
"    def graph(self, varNames):\n"
"        \"\"\"\n"
"        Show one or several variables in a graph.\n"
"\n"
"        The X-axis is always the time, the specified variables appear on the \n"
"        Y-Axis.\n"
"        Parameter:\n"
"        varNames:   Text string with a list of variables to be plotted. (Space or \n"
"                    comma seperated.) e.g.: 'r.X r.mu'\n"
"        Example:\n"
"            >>> mySimulationObject.graph('r.X r.mu')\n"
"        \"\"\"\n"
"\n"
"        diagram=Gnuplot.Gnuplot(debug=0, persist=1)\n"
"        diagram('set data style lines')\n"
"        diagram.title(varNames)\n"
"        diagram.xlabel('Time')\n"
"\n"
"        varList = varNames.replace(',', ' ').split(' ')\n"
"        for varName1 in varList:\n"
"            if not (varName1 in self._resultArrayMap): \n"
"                print('Error unknown variable name: %s') % varName1\n"
"                continue\n"
"                \n"
"            curve=Gnuplot.Data(self.get('time'), self.get(varName1))\n"
"            diagram.replot(curve)\n"
"\n"
"    def simulateDynamic(self):\n"
"        \"\"\"\n"
"        Perform a dynamic simulation.\n"
"        \n"
"        The results can be displayed with the graph(...) function.\n"
"        The funcion get(...) returns the simulation result of a speciffic\n"
"        variable as a vector.\n"
"        \"\"\"\n"
"\n"
"##        #The numerical integration changes the initial values, but the user maybe \n"
"##        #wants to compute them in advance\n"
"##        if self._initialValuesDirty :\n"
"##            #Compute the initial values. (They are overwritten by integrate.odeint)\n"
"##            self._initialValues = self.setInitialValues()\n"
"##        self._initialValuesDirty = True;\n"
"        \n"
"        #Compute the initial values. (They are overwritten by integrate.odeint)\n"
"        initialValues = self.setInitialValues()\n"
"        #create the array of output time points\n"
"        self.time = linspace(0.0, self.simulationTime, self.simulationTime/self.reportingInterval + 1) #note: no rounding is better, linspace is quite smart.\n"
"        #compute the numerical solution\n"
"        y = integrate.odeint(self._diffStateT, initialValues, self.time)\n"
"        #compute the algebraic variables for a second time, so they can be shown in graphs.\n"
"        self._resultArray = self._outputEquations(y)\n"
"\n"
"    def simulateSteadyState(self):\n"
"        \"\"\"\n"
"        Perform a stady state simulation.\n"
"        \n"
"        This function computes one steady state solution, of the system of \n"
"        differential equations. Which solution of the potentially many solutions\n"
"        is found, depends on the initial guess. A steady state solution is a \n"
"        vector of all variables. This vector is appended to the array of results.\n"
"        Usually one will compute a series of stady state solutions, each with \n"
"        slightly different parameters.\n"
"        \n"
"        Initial guess: When there are no prior results, the initial values are\n"
"        (ab)used as an initial guess; otherwise the latest results are used as \n"
"        the initial guess.\n"
"        In the time array the count of current simulation is stored. This way the \n"
"        graph function still produces useful graphs with steady state simulations.\n"
"\n"
"        The final results can be displayed with the graph(...) function.\n"
"        The funcion get(...) returns the simulation result of a speciffic\n"
"        variable as a vector.\n"
"        \"\"\"\n"
"        \n"
"        if not hasattr(self, 'time'):\n"
"            #this is the first call in a row of steady state simulations - setup everything\n"
"            lastResult = -1\n"
"            self._resultArray = array([[0]], Float)\n"
"            self.time = array([0], Float)\n"
"            x0 = self.setInitialValues()    #initial guess for root finder: initial values abused\n"
"            t0 = -1\n"
"        else:\n"
"            lastResult = shape(self._resultArray)[0]-1\n"
"            x0 = self._resultArray[lastResult, 0:self._numStates] #initial guess for root finder: last result\n"
"            t0 = self.time[lastResult] \n"
"        \n"
"        #compute the state variables of the steady state solution\n"
"        (xmin, msg) = optimize.leastsq(self._diffStateT, x0, (0)) #funcion will also report local minima that are no roots. Caution!\n"
"##        xmin = optimize.fsolve(self._diffStateT, x0, (0)) #function is always stuck in one (the trivial) minimum \n"
"        #also compute the algebraic variables\n"
"        currRes = self._outputEquations(xmin)\n"
"        #expand the storage and save the results\n"
"        self._resultArray = resize(self._resultArray, (lastResult+2, self._numVariables))\n"
"        self._resultArray[lastResult+1,:] = currRes[0,:]\n"
"        self.time = resize(self.time, (lastResult+2,))\n"
"        self.time[lastResult+1] = t0 + 1\n"
"\n"
"\n"
