<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<?xml-stylesheet href="theme/style.css" type="text/css"?>
<head>
<!-- Generated by the Spirit (http://spirit.sf.net) QuickDoc -->
<title>Grammar overview</title>
<link rel="stylesheet" href="theme/style.css" type="text/css"/>
<link rel="prev" href="introduction.html"/>
<link rel="next" href="virtual_machine.html"/>
</head>
<body>
<table class="title" width="100%" border="0" cellspacing="2">
  <tr>
    <td>
Grammar overview    </td>
    <td style="text-align: right;"><a href="http://spirit.sourceforge.net"><img alt="SPIRIT" src="theme/spirit.gif" ></img></a></td>
  </tr>
</table>
<table style="margin-top: 10px;">
  <tr>
    <td><a href="../index.html"><img alt="TOP" src="theme/u_arr.gif"></img></a></td>
    <td><a href="introduction.html"><img alt="PREVIOUS" src="theme/l_arr.gif"></img></a></td>
    <td><a href="virtual_machine.html"><img alt="NEXT" src="theme/r_arr.gif"></img></a></td>
   </tr>
</table>
<p>
The <a href="http://www.gnuplot.info">
Gnuplot</a>-style syntax is defined by <tt>statement_list</tt> in the
grammar below. Omitted from this listing is the specification of <tt>expression</tt>,
 in order to make clear the overall structure of the language. The grammar
 defining <tt>expression</tt>, (to be found <a href="#expression">
here</a>) provides the rules
 by which expressions such as  <tt>2+3*sin(sqrt(x)/y(x))</tt> are parsed (where <tt>x</tt>
 and <tt>y</tt> are a previously declared variable and function, respectively).</p>
<pre><code>
    statement_list      ::= (statement ('\n' | ';')+)*
    statement           ::= var_assignment
                          | function_definition
                          | &quot;print &quot; expression_list
    expression_list     ::= expression (',' expression)*
    var_assignment      ::= name '=' expression
    function_definition ::= name '(' name_list? ')' '=' expression
    name_list           ::= name (',' name)*
    name                ::= (alpha_p | '_') (alnum_p | '_')* </code></pre><p>
Here, <tt>alpha_p</tt> and <tt>alnum_p</tt> are <a href="http://spirit.sourceforge.net">
Spirit</a> primitives meaning any alphabetic
character [A-Za-z] and any character [A-Za-z0-9],
respectively. Some points to note about this grammar:</p>
<ul><li>Individual statements are terminated either by a new line or by a <tt>;</tt> character. Multiple new lines or <tt>;</tt> characters are allowed together, as in C.</li><li>variable declarations are implicit. The variable <tt>x</tt> is placed in the table of known variables immediately after the entire <tt>statement</tt>, e.g. <tt>x=sin(2*pi*t/T)</tt>, is parsed. All variables are of type double.</li><li>function definitions are very simple, consisting of a single <tt>expression</tt> only. Arguments are passed by value. It is implicitly understood that the result of this expression is the value returned by the function. A typical example might be <tt>axpy(a,b,c)=a*b+c</tt>.</li><li>functions with the same name but different argument lists can be overloaded. (<b>YAC</b> differs in this regard from <a href="http://www.gnuplot.info">
Gnuplot</a>.) The statement list below will be handled correctly by <b>YAC</b>, but will fail in <a href="http://www.gnuplot.info">
Gnuplot</a> at line 2. Interestingly, <a href="http://www.gnuplot.info">
Gnuplot</a> (and <b>YAC</b>) will both allow variables and functions with the same name to co-exist.</li></ul><pre><code>
    0    foo(a)=2+a
    1    foo(a,b)=a*b
    2    print foo(3)    # outputs 5
    3    print foo(3,4)  # outputs 12 </code></pre><h1><a id="skip_grammar"></a>Skip grammar</h1><p>
The grammar definition above provides only part of the story. The rest
comes from the definition of what to ignore. The <a href="http://www.gnuplot.info">
Gnuplot</a>-style syntax
dictates that the skip grammar is defined as:</p>
<pre><code>
    skip       ::= whitespace
                 | '\\' whitespace* '\n'
                 | '#' (anychar_p - '\n')*
    whitespace ::= space_p - '\n' </code></pre><p>
<tt>space_p</tt> and <tt>anychar_p</tt> are <a href="http://spirit.sourceforge.net">
Spirit</a> primitives matching any
character that matches the C standard library routine <tt>isspace</tt> and
any character at all, respectively.</p>
<p>
Note that <tt>\n</tt> is used by the main grammar to signify the end of a
statement. This grammar will ignore whitespace other than <tt>\n</tt> and will treat
anything following a <tt>'#'</tt> as a comment.</p>
<p>
The <tt>&quot;\\\n&quot;</tt> grouping is used to continue a single statement over more than one
line. This continuation behaviour is less sophisticated than that found in a
Unix shell but is identical to that of <a href="http://www.gnuplot.info">
Gnuplot</a>. An expression such as:</p>
<pre><code>
    foo(a,b) = \ # Function declaration
        a + b    # Function definition </code></pre><p>
is illegal. This is a legal use of <tt>\</tt>:</p>
<pre><code>
    foo(a,b) =   # Function declaration \
        a + b    # Function definition </code></pre><p>
but it does no more than continue the comment. (Parsing will fail
thereafter because the function has no definition.)</p>
<h1><a id="expression"></a>expression</h1><p>
The expression grammar is essentially similar to that of C and is defined
formally by <tt>expr</tt> below:</p>
<pre><code>
    expr          ::= logical_expr conditional_expr_helper?
    conditional_expr_helper ::= '?' expr ':' expr conditional_expr_helper?
    logical_expr  ::= bitwise_expr  ((&quot;&amp;&amp;&quot; | &quot;||&quot;) bitwise_expr)*
    bitwise_expr  ::= equality_expr (('&amp;' | '|' | '^') equality_expr)*
    equality_expr ::= compare_expr  ((&quot;==&quot; | &quot;!=&quot;) compare_expr)*
    compare_expr  ::= shift_expr    (('&lt;' | '&gt;' | &quot;&lt;=&quot; | &quot;&gt;=&quot;) shift_expr)*
    shift_expr    ::= add_expr      ((&quot;&lt;&lt;&quot; | &quot;&gt;&gt;&quot;) add_expr)*
    add_expr      ::= mult_expr     (('+' | '-') mult_expr)*
    mult_expr     ::= expr_atom     (('*' | '/' | '%') expr_atom)*
    expr_atom     ::= number
                    | function
                    | '(' expr ')'
                    | ('+' | '-' | '!') expr_atom
    number        ::= real_p | local_vars | global_vars
    function      ::= name '(' arg_list? ')'
    arg_list      ::= expr (',' expr)* </code></pre><p>
<tt>real_p</tt> is a <a href="http://spirit.sourceforge.net">
Spirit</a> primitive that will match any real number. <tt>local_vars</tt>
and <tt>global_vars</tt> are symbol tables of recognized local and global variables
respectively. Similarly, <tt>function</tt> must be found in the symbol table of known
functions for the parser to pass the input as valid.</p>
<p>
Some points to note:</p>
<ul><li>Most operations have left associativity, meaning that an expression like <tt>a+b+c</tt> is interpreted to mean <tt>(a+b)+c</tt>. The exception to this is the ternary if-else operator which has middle and right associativity. Middle associativity means that an expression like <tt>a?b?c:d:e</tt> is allowed and should be interpreted to mean <tt>a?(b?c:d):e</tt>. Right associativity means that <tt>a?b:c?d:e</tt> is allowed and should be interpreted to mean <tt>a?b:(c?d:e)</tt>. The grammar handles all these cases correctly. These associativity rules are identical to those of C.</li><li>The cascading nature of the grammar specification ensures that precedence of the possible operations increases from <tt>logical_expr</tt> at the top to <tt>expr_atom</tt> at the bottom. Thus <tt>a+b*c</tt> is parsed as <tt>a+(b*c)</tt>. These precedence rules are identical to those of C.</li><li>The arguments to various operations (<tt>&amp;</tt>, <tt>|</tt>, <tt>^</tt>, <tt>&lt;&lt;</tt>, <tt>&gt;&gt;</tt>, <tt>%</tt>) are cast implicitly to <tt>int</tt> before invoking the operator, (because the underlying C++ code requires that these operations be performed on <tt>int</tt>s). The grammar has no notion of type; it just happens, OK!</li></ul><p>
This completes the formal definition of the grammar. An implementation of this
grammar using <a href="http://spirit.sourceforge.net">
Spirit</a> can be found <a href="../src/example_parser.cpp">
here</a>. It
conforms to the definition above exactly, save for the limitation that no
symbol tables are checked when parsing any variables or functions.</p>
<p>
The code does nothing more than flag whether the input data conforms to the
grammar. What it does demonstrate, however, is that writing a parser using <a href="http://spirit.sourceforge.net">
Spirit</a>
is trivially easy once the grammar has been specified formally. The fun and
games start when we try and attach semantic actions to each parsed snippet.</p>
<table style="margin-top: 10px;">
  <tr>
    <td><a href="../index.html"><img alt="TOP" src="theme/u_arr.gif"></img></a></td>
    <td><a href="introduction.html"><img alt="PREVIOUS" src="theme/l_arr.gif"></img></a></td>
    <td><a href="virtual_machine.html"><img alt="NEXT" src="theme/r_arr.gif"></img></a></td>
   </tr>
</table>
<hr/>
<p>
  <a href="http://validator.w3.org/check/referer">
    <img style="border:0;width:88px;height:31px"
      src="theme/valid-xhtml11.png"
      alt="Valid XHTML 1.1!" />
  </a>
  <a href="http://jigsaw.w3.org/css-validator/check/referer">
    <img style="border:0;width:88px;height:31px"
      src="theme/vcss.png"
      alt="Valid CSS!" />
  </a>
</p>
<p class="copyright">

  Copyright &copy; 2004 Angus Leeming<br/><br/>
  Distributed under the Boost Software License,
  Version 1.0. (See accompanying file
  <a href="../LICENSE_1_0.txt">LICENSE_1_0.txt</a> or copy at
  <a href="http://www.boost.org/LICENSE_1_0.txt">
     http://www.boost.org/LICENSE_1_0.txt
  </a>)

</p>
</body>
</html>
