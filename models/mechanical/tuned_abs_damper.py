#!/usr/bin/env python
################################################################################
#                            Warning: Do not edit!                             #
#                                                                              #
# This file is generated, it will be overwritten every time the source file(s) #
# is/are changed.                                                              #
# If you want to change the behaviour of a simulation object                   #
# write a main routine in an other file. Use import or execfile to load        #
# the objects defined in this file into the Python interpreter.                #
################################################################################
# Generated by SIML compiler version 0.3.0 on 2007-02-12 00:21:32. 
# Source file(s): /home/eike/codedir/freeode/trunk/models/mechanical/tuned_abs_damper.siml
################################################################################


from numpy import array, sqrt
#from scipy import *
from freeode.simulatorbase import SimulatorBase
from freeode.simulatorbase import simulatorMainFunc


class Experiment0(SimulatorBase): 
    ''' 
    Object to simulate process Experiment0 
    Definition in
    file: '/home/eike/codedir/freeode/trunk/models/mechanical/tuned_abs_damper.siml'
    line: 119 
    ''' 
    
    def __init__(self): 
        super(Experiment0, self).__init__() 
        self.defaultFileName = 'Experiment0.simres' 
        #create all parameters with value 0; to prevent runtime errors. 
        self.p_sweep_fMin = 0.0 
        self.p_r_d2 = 0.0 
        self.p_sweep_rampDuration = 0.0 
        self.p_r_d = 0.0 
        self.p_r_c = 0.0 
        self.p_r_c2 = 0.0 
        self.p_r_m = 0.0 
        self.p_sweep_fMax = 0.0 
        self.p_solutionParameters_simulationTime = 0.0 
        self.p_r_m2 = 0.0 
        self.p_AmpFe = 0.0 
        self.p_solutionParameters_reportingInterval = 0.0 


    def initialize(self,  *args, **kwArgs): 
        ''' 
        Compute parameter values and 
        compute initial values of state variables 
        ''' 
        #create all variables with value 0; to prevent runtime errors.
        v_sweep_x = 0.0 
        v_sweep_frequ = 0.0 
        v_r_F = 0.0 
        v_r_x2 = 0.0 
        v_r_v = 0.0 
        v_r_v2 = 0.0 
        v_r_x = 0.0 
        #create dict for parameter override 
        ovd = self._createParamOverrideDict(args, kwArgs) 
        #do computations 
        self.p_solutionParameters_simulationTime = 200.0
        self.p_solutionParameters_reportingInterval = 0.01
        self.p_sweep_fMin = 1.0
        self.p_sweep_fMax = 10.0
        self.p_sweep_rampDuration = 100.0
        self.p_sweep_fMin = 0.8
        self.p_sweep_fMax = 1.15
        self.p_sweep_rampDuration = self.p_solutionParameters_simulationTime
        self.p_AmpFe = 10.0
        self.p_r_m = 1.0
        self.p_r_c = 1.0
        self.p_r_d = 0.0
        v_r_x = 0.0
        v_r_v = 0.0
        self.p_r_m2 = 1.0
        self.p_r_c2 = 1.0
        self.p_r_d2 = 0.0
        v_r_x2 = 0.0
        v_r_v2 = 0.0
        self.p_r_m = 100.0
        self.p_r_c = 5000.0
        self.p_r_d = 2.0
        self.p_r_m2 = 2.1
        self.p_r_c2 = 100.0
        self.p_r_d2 = 2.2
        
        #assemble initial values to array and store them 
        self.initialValues = array([v_r_x2, v_r_v, v_r_v2, v_r_x, ], 'float64')
        self.stateVectorLen = len(self.initialValues) 
        #put algebraic variables into array, only to compute its size 
        algVars = array([v_sweep_x, v_sweep_frequ, v_r_F, ], 'float64')
        self.algVectorLen = len(algVars) 
        #Create maping between variable names and array indices 
        self.variableNameMap = {'r.x2':0, 'r.v':1, 'r.v2':2, 'r.x':3, 
                'sweep.x':4, 'sweep.frequ':5, 'r.F':6, }


    def dynamic(self, time, state, returnAlgVars=False): 
        ''' 
        Compute time derivative of state variables. 
        This function will be called by the solver repeatedly. 
        ''' 
        #take the state variables out of the state vector 
        v_r_x2 = state[0] 
        v_r_v = state[1] 
        v_r_v2 = state[2] 
        v_r_x = state[3] 
        #do computations 
        v_sweep_frequ = self.p_sweep_fMin + time*(self.p_sweep_fMax - self.p_sweep_fMin)/self.p_sweep_rampDuration
        v_sweep_x = sin(time*2.0*pi*v_sweep_frequ)
        v_r_F = self.p_AmpFe*v_sweep_x
        v_r_v_dt = ( -self.p_r_c*v_r_x - self.p_r_d*v_r_v + v_r_F + self.p_r_c2*(v_r_x2 - v_r_x) + self.p_r_d2*(v_r_v2 - v_r_v))/self.p_r_m
        v_r_x_dt = v_r_v
        v_r_v2_dt = ( -self.p_r_c2*(v_r_x2 - v_r_x) - self.p_r_d2*(v_r_v2 - v_r_v))/self.p_r_m2
        v_r_x2_dt = v_r_v2
        
        if returnAlgVars: 
            #put algebraic variables into array 
            algVars = array([v_sweep_x, v_sweep_frequ, v_r_F, ], 'float64')
            return algVars 
        else: 
            #assemble the time derivatives into the return vector 
            stateDt = array([v_r_x2_dt, v_r_v_dt, v_r_v2_dt, v_r_x_dt, ], 'float64')
            return stateDt 


    def final(self): 
        ''' 
        Display and save simulation results. 
        This function will be called once; after the simulation results 
        have been computed. 
        ''' 
        #the final method's statements 
        self.graph(['r.x', 'r.x2', ], ) 
        self.graph(['sweep.frequ', ], ) 
        print 'simulation Experiment0 finished.'
        


class Experiment1(SimulatorBase): 
    ''' 
    Object to simulate process Experiment1 
    Definition in
    file: '/home/eike/codedir/freeode/trunk/models/mechanical/tuned_abs_damper.siml'
    line: 163 
    ''' 
    
    def __init__(self): 
        super(Experiment1, self).__init__() 
        self.defaultFileName = 'Experiment1.simres' 
        #create all parameters with value 0; to prevent runtime errors. 
        self.p_sweep_fMin = 0.0 
        self.p_r_d2 = 0.0 
        self.p_sweep_rampDuration = 0.0 
        self.p_r_d = 0.0 
        self.p_r_c = 0.0 
        self.p_r_c2 = 0.0 
        self.p_r_m = 0.0 
        self.p_sweep_fMax = 0.0 
        self.p_solutionParameters_simulationTime = 0.0 
        self.p_r_m2 = 0.0 
        self.p_AmpFe = 0.0 
        self.p_solutionParameters_reportingInterval = 0.0 


    def initialize(self,  *args, **kwArgs): 
        ''' 
        Compute parameter values and 
        compute initial values of state variables 
        ''' 
        #create all variables with value 0; to prevent runtime errors.
        v_sweep_x = 0.0 
        v_sweep_frequ = 0.0 
        v_r_F = 0.0 
        v_r_x2 = 0.0 
        v_r_v = 0.0 
        v_r_v2 = 0.0 
        v_r_x = 0.0 
        #create dict for parameter override 
        ovd = self._createParamOverrideDict(args, kwArgs) 
        #do computations 
        self.p_solutionParameters_simulationTime = 200.0
        self.p_solutionParameters_reportingInterval = 0.01
        self.p_sweep_fMin = 1.0
        self.p_sweep_fMax = 10.0
        self.p_sweep_rampDuration = 100.0
        self.p_sweep_fMin = 0.8
        self.p_sweep_fMax = 1.15
        self.p_sweep_rampDuration = self.p_solutionParameters_simulationTime
        self.p_AmpFe = 10.0
        self.p_r_m = 1.0
        self.p_r_c = 1.0
        self.p_r_d = 0.0
        v_r_x = 0.0
        v_r_v = 0.0
        self.p_r_m2 = 1.0
        self.p_r_c2 = 1.0
        self.p_r_d2 = 0.0
        v_r_x2 = 0.0
        v_r_v2 = 0.0
        self.p_r_m = 100.0
        self.p_r_c = 5000.0
        self.p_r_d = 2.0
        self.p_r_m2 = 1.0
        self.p_r_c2 = 0.0
        self.p_r_d2 = 0.0
        
        #assemble initial values to array and store them 
        self.initialValues = array([v_r_x2, v_r_v, v_r_v2, v_r_x, ], 'float64')
        self.stateVectorLen = len(self.initialValues) 
        #put algebraic variables into array, only to compute its size 
        algVars = array([v_sweep_x, v_sweep_frequ, v_r_F, ], 'float64')
        self.algVectorLen = len(algVars) 
        #Create maping between variable names and array indices 
        self.variableNameMap = {'r.x2':0, 'r.v':1, 'r.v2':2, 'r.x':3, 
                'sweep.x':4, 'sweep.frequ':5, 'r.F':6, }


    def dynamic(self, time, state, returnAlgVars=False): 
        ''' 
        Compute time derivative of state variables. 
        This function will be called by the solver repeatedly. 
        ''' 
        #take the state variables out of the state vector 
        v_r_x2 = state[0] 
        v_r_v = state[1] 
        v_r_v2 = state[2] 
        v_r_x = state[3] 
        #do computations 
        v_sweep_frequ = self.p_sweep_fMin + time*(self.p_sweep_fMax - self.p_sweep_fMin)/self.p_sweep_rampDuration
        v_sweep_x = sin(time*2.0*pi*v_sweep_frequ)
        v_r_F = self.p_AmpFe*v_sweep_x
        v_r_v_dt = ( -self.p_r_c*v_r_x - self.p_r_d*v_r_v + v_r_F + self.p_r_c2*(v_r_x2 - v_r_x) + self.p_r_d2*(v_r_v2 - v_r_v))/self.p_r_m
        v_r_x_dt = v_r_v
        v_r_v2_dt = ( -self.p_r_c2*(v_r_x2 - v_r_x) - self.p_r_d2*(v_r_v2 - v_r_v))/self.p_r_m2
        v_r_x2_dt = v_r_v2
        
        if returnAlgVars: 
            #put algebraic variables into array 
            algVars = array([v_sweep_x, v_sweep_frequ, v_r_F, ], 'float64')
            return algVars 
        else: 
            #assemble the time derivatives into the return vector 
            stateDt = array([v_r_x2_dt, v_r_v_dt, v_r_v2_dt, v_r_x_dt, ], 'float64')
            return stateDt 


    def final(self): 
        ''' 
        Display and save simulation results. 
        This function will be called once; after the simulation results 
        have been computed. 
        ''' 
        #the final method's statements 
        self.graph(['r.x', 'r.x2', ], ) 
        print 'simulation Experiment1 finished.'
        


class StepExperiment(SimulatorBase): 
    ''' 
    Object to simulate process StepExperiment 
    Definition in
    file: '/home/eike/codedir/freeode/trunk/models/mechanical/tuned_abs_damper.siml'
    line: 204 
    ''' 
    
    def __init__(self): 
        super(StepExperiment, self).__init__() 
        self.defaultFileName = 'StepExperiment.simres' 
        #create all parameters with value 0; to prevent runtime errors. 
        self.p_r_d2 = 0.0 
        self.p_r_d = 0.0 
        self.p_r_c = 0.0 
        self.p_r_c2 = 0.0 
        self.p_r_m = 0.0 
        self.p_solutionParameters_simulationTime = 0.0 
        self.p_r_m2 = 0.0 
        self.p_solutionParameters_reportingInterval = 0.0 


    def initialize(self,  *args, **kwArgs): 
        ''' 
        Compute parameter values and 
        compute initial values of state variables 
        ''' 
        #create all variables with value 0; to prevent runtime errors.
        v_r_F = 0.0 
        v_r_x2 = 0.0 
        v_r_v = 0.0 
        v_r_v2 = 0.0 
        v_r_x = 0.0 
        #create dict for parameter override 
        ovd = self._createParamOverrideDict(args, kwArgs) 
        #do computations 
        self.p_solutionParameters_simulationTime = 20.0
        self.p_solutionParameters_reportingInterval = 0.01
        self.p_r_m = 1.0
        self.p_r_c = 1.0
        self.p_r_d = 0.0
        v_r_x = 0.0
        v_r_v = 0.0
        self.p_r_m2 = 1.0
        self.p_r_c2 = 1.0
        self.p_r_d2 = 0.0
        v_r_x2 = 0.0
        v_r_v2 = 0.0
        self.p_r_m = 100.0
        self.p_r_c = 5000.0
        self.p_r_d = 2.0
        self.p_r_m2 = 1.0
        self.p_r_c2 = 0.0
        self.p_r_d2 = 0.0
        v_r_x = 1.0
        
        #assemble initial values to array and store them 
        self.initialValues = array([v_r_x2, v_r_v, v_r_v2, v_r_x, ], 'float64')
        self.stateVectorLen = len(self.initialValues) 
        #put algebraic variables into array, only to compute its size 
        algVars = array([v_r_F, ], 'float64')
        self.algVectorLen = len(algVars) 
        #Create maping between variable names and array indices 
        self.variableNameMap = {'r.x2':0, 'r.v':1, 'r.v2':2, 'r.x':3, 'r.F':4, }


    def dynamic(self, time, state, returnAlgVars=False): 
        ''' 
        Compute time derivative of state variables. 
        This function will be called by the solver repeatedly. 
        ''' 
        #take the state variables out of the state vector 
        v_r_x2 = state[0] 
        v_r_v = state[1] 
        v_r_v2 = state[2] 
        v_r_x = state[3] 
        #do computations 
        v_r_F = 0.0
        v_r_v_dt = ( -self.p_r_c*v_r_x - self.p_r_d*v_r_v + v_r_F + self.p_r_c2*(v_r_x2 - v_r_x) + self.p_r_d2*(v_r_v2 - v_r_v))/self.p_r_m
        v_r_x_dt = v_r_v
        v_r_v2_dt = ( -self.p_r_c2*(v_r_x2 - v_r_x) - self.p_r_d2*(v_r_v2 - v_r_v))/self.p_r_m2
        v_r_x2_dt = v_r_v2
        
        if returnAlgVars: 
            #put algebraic variables into array 
            algVars = array([v_r_F, ], 'float64')
            return algVars 
        else: 
            #assemble the time derivatives into the return vector 
            stateDt = array([v_r_x2_dt, v_r_v_dt, v_r_v2_dt, v_r_x_dt, ], 'float64')
            return stateDt 


    def final(self): 
        ''' 
        Display and save simulation results. 
        This function will be called once; after the simulation results 
        have been computed. 
        ''' 
        #the final method's statements 
        pass 
        print 'simulation StepExperiment finished.'
        




#Main function - executed when file (module) runs as an independent program.
#When file is imported into other programs, if-condition is false.
if __name__ == '__main__':
    simulatorClasses = [Experiment0, Experiment1, StepExperiment, ]
    simulatorMainFunc(simulatorClasses) #in module simulatorbase

