#!/usr/bin/env python
################################################################################
#                            Warning: Do not edit!                             #
#                                                                              #
# This file is generated, it will be overwritten every time the source file(s) #
# is/are changed.                                                              #
# If you want to change the behaviour of a simulation object                   #
# write a main routine in an other file. Use import or execfile to load        #
# the objects defined in this file into the Python interpreter.                #
################################################################################
# Generated by SIML compiler version 0.3.0 on 2007-02-12 00:23:23. 
# Source file(s): /home/eike/codedir/freeode/trunk/models/biological/bioreactor.siml
################################################################################


from numpy import array, sqrt
#from scipy import *
from freeode.simulatorbase import SimulatorBase
from freeode.simulatorbase import simulatorMainFunc


class Batch(SimulatorBase): 
    ''' 
    Object to simulate process Batch 
    Definition in
    file: '/home/eike/codedir/freeode/trunk/models/biological/bioreactor.siml'
    line: 37 
    ''' 
    
    def __init__(self): 
        super(Batch, self).__init__() 
        self.defaultFileName = 'Batch.simres' 
        #create all parameters with value 0; to prevent runtime errors. 
        self.p_ms = 0.0 
        self.p_X_init = 0.0 
        self.p_Sf = 0.0 
        self.p_Yxs = 0.0 
        self.p_mu_max = 0.0 
        self.p_D = 0.0 
        self.p_Ks = 0.0 
        self.p_solutionParameters_simulationTime = 0.0 
        self.p_solutionParameters_reportingInterval = 0.0 
        self.p_S_init = 0.0 


    def initialize(self,  *args, **kwArgs): 
        ''' 
        Compute parameter values and 
        compute initial values of state variables 
        ''' 
        #create all variables with value 0; to prevent runtime errors.
        v_r_mu = 0.0 
        v_r_STY = 0.0 
        v_r_D = 0.0 
        v_r_S = 0.0 
        v_r_X = 0.0 
        #create dict for parameter override 
        ovd = self._createParamOverrideDict(args, kwArgs) 
        #do computations 
        self.p_solutionParameters_simulationTime = 20.0
        self.p_solutionParameters_reportingInterval = 0.1
        self.p_mu_max = 0.32
        self.p_Ks = 0.01
        self.p_Yxs = 0.5
        self.p_Sf = 20.0
        self.p_D = 0.0
        self.p_ms = 0.02
        self.p_X_init = 0.1
        self.p_S_init = 20.0
        v_r_X = self.p_X_init
        v_r_S = self.p_S_init
        
        #assemble initial values to array and store them 
        self.initialValues = array([v_r_S, v_r_X, ], 'float64')
        self.stateVectorLen = len(self.initialValues) 
        #put algebraic variables into array, only to compute its size 
        algVars = array([v_r_mu, v_r_STY, v_r_D, ], 'float64')
        self.algVectorLen = len(algVars) 
        #Create maping between variable names and array indices 
        self.variableNameMap = {'r.S':0, 'r.X':1, 'r.mu':2, 'r.STY':3, 'r.D':4, }


    def dynamic(self, time, state, returnAlgVars=False): 
        ''' 
        Compute time derivative of state variables. 
        This function will be called by the solver repeatedly. 
        ''' 
        #take the state variables out of the state vector 
        v_r_S = state[0] 
        v_r_X = state[1] 
        #do computations 
        v_r_D = self.p_D
        if v_r_S > 0.0:
            v_r_mu = self.p_mu_max*v_r_S/(v_r_S + self.p_Ks)
        else: 
            v_r_mu = 0.0
        v_r_X_dt = v_r_mu*v_r_X - v_r_D*v_r_X
        v_r_S_dt =  -1.0/self.p_Yxs*v_r_mu*v_r_X + v_r_D*self.p_Sf - v_r_D*v_r_S - self.p_ms*v_r_X
        v_r_STY = v_r_X*v_r_D
        
        if returnAlgVars: 
            #put algebraic variables into array 
            algVars = array([v_r_mu, v_r_STY, v_r_D, ], 'float64')
            return algVars 
        else: 
            #assemble the time derivatives into the return vector 
            stateDt = array([v_r_S_dt, v_r_X_dt, ], 'float64')
            return stateDt 


    def final(self): 
        ''' 
        Display and save simulation results. 
        This function will be called once; after the simulation results 
        have been computed. 
        ''' 
        #the final method's statements 
        self.graph(['r.mu', 'r.X', 'r.S', ], 'Batch') 
        print 'simulation Batch finished.'
        


class Conti(SimulatorBase): 
    ''' 
    Object to simulate process Conti 
    Definition in
    file: '/home/eike/codedir/freeode/trunk/models/biological/bioreactor.siml'
    line: 84 
    ''' 
    
    def __init__(self): 
        super(Conti, self).__init__() 
        self.defaultFileName = 'Conti.simres' 
        #create all parameters with value 0; to prevent runtime errors. 
        self.p_ms = 0.0 
        self.p_X_init = 0.0 
        self.p_Sf = 0.0 
        self.p_Yxs = 0.0 
        self.p_mu_max = 0.0 
        self.p_D = 0.0 
        self.p_Ks = 0.0 
        self.p_solutionParameters_simulationTime = 0.0 
        self.p_solutionParameters_reportingInterval = 0.0 
        self.p_S_init = 0.0 
        self.p_show_graph = 0.0 


    def initialize(self,  *args, **kwArgs): 
        ''' 
        Compute parameter values and 
        compute initial values of state variables 
        ''' 
        #create all variables with value 0; to prevent runtime errors.
        v_r_mu = 0.0 
        v_r_STY = 0.0 
        v_r_D = 0.0 
        v_r_S = 0.0 
        v_r_X = 0.0 
        #create dict for parameter override 
        ovd = self._createParamOverrideDict(args, kwArgs) 
        #do computations 
        self.p_solutionParameters_simulationTime = 40.0
        self.p_solutionParameters_reportingInterval = 0.1
        self.p_mu_max = 0.32
        self.p_Ks = 0.01
        self.p_Yxs = 0.5
        self.p_Sf = 20.0
        self.p_D = 0.1
        self.p_ms = 0.02
        self.p_X_init = 0.1
        self.p_S_init = 0.0
        self.p_show_graph = 1.0
        v_r_X = self.p_X_init
        v_r_S = self.p_S_init
        
        #assemble initial values to array and store them 
        self.initialValues = array([v_r_S, v_r_X, ], 'float64')
        self.stateVectorLen = len(self.initialValues) 
        #put algebraic variables into array, only to compute its size 
        algVars = array([v_r_mu, v_r_STY, v_r_D, ], 'float64')
        self.algVectorLen = len(algVars) 
        #Create maping between variable names and array indices 
        self.variableNameMap = {'r.S':0, 'r.X':1, 'r.mu':2, 'r.STY':3, 'r.D':4, }


    def dynamic(self, time, state, returnAlgVars=False): 
        ''' 
        Compute time derivative of state variables. 
        This function will be called by the solver repeatedly. 
        ''' 
        #take the state variables out of the state vector 
        v_r_S = state[0] 
        v_r_X = state[1] 
        #do computations 
        v_r_D = self.p_D
        if v_r_S > 0.0:
            v_r_mu = self.p_mu_max*v_r_S/(v_r_S + self.p_Ks)
        else: 
            v_r_mu = 0.0
        v_r_X_dt = v_r_mu*v_r_X - v_r_D*v_r_X
        v_r_S_dt =  -1.0/self.p_Yxs*v_r_mu*v_r_X + v_r_D*self.p_Sf - v_r_D*v_r_S - self.p_ms*v_r_X
        v_r_STY = v_r_X*v_r_D
        
        if returnAlgVars: 
            #put algebraic variables into array 
            algVars = array([v_r_mu, v_r_STY, v_r_D, ], 'float64')
            return algVars 
        else: 
            #assemble the time derivatives into the return vector 
            stateDt = array([v_r_S_dt, v_r_X_dt, ], 'float64')
            return stateDt 


    def final(self): 
        ''' 
        Display and save simulation results. 
        This function will be called once; after the simulation results 
        have been computed. 
        ''' 
        #the final method's statements 
        if self.p_show_graph != 0.0:
            self.graph(['r.mu', 'r.X', 'r.S', ], 'Conti') 
            self.graph(['r.D', 'r.mu', ], 'Conti') 
        else: 
            pass 
        print 'simulation Conti finished.'
        


class ContiSmartStart(SimulatorBase): 
    ''' 
    Object to simulate process ContiSmartStart 
    Definition in
    file: '/home/eike/codedir/freeode/trunk/models/biological/bioreactor.siml'
    line: 134 
    ''' 
    
    def __init__(self): 
        super(ContiSmartStart, self).__init__() 
        self.defaultFileName = 'ContiSmartStart.simres' 
        #create all parameters with value 0; to prevent runtime errors. 
        self.p_ms = 0.0 
        self.p_X_init = 0.0 
        self.p_Sf = 0.0 
        self.p_Yxs = 0.0 
        self.p_mu_max = 0.0 
        self.p_Ks = 0.0 
        self.p_solutionParameters_simulationTime = 0.0 
        self.p_D_fin = 0.0 
        self.p_solutionParameters_reportingInterval = 0.0 
        self.p_S_init = 0.0 
        self.p_show_graph = 0.0 


    def initialize(self,  *args, **kwArgs): 
        ''' 
        Compute parameter values and 
        compute initial values of state variables 
        ''' 
        #create all variables with value 0; to prevent runtime errors.
        v_r_mu = 0.0 
        v_r_STY = 0.0 
        v_r_D = 0.0 
        v_r_S = 0.0 
        v_r_X = 0.0 
        #create dict for parameter override 
        ovd = self._createParamOverrideDict(args, kwArgs) 
        #do computations 
        self.p_solutionParameters_simulationTime = 40.0
        self.p_solutionParameters_reportingInterval = 0.1
        self.p_mu_max = 0.32
        self.p_Ks = 0.01
        self.p_Yxs = 0.5
        self.p_Sf = 20.0
        self.p_D_fin = 0.3
        self.p_ms = 0.02
        self.p_X_init = 0.1
        self.p_S_init = 20.0
        self.p_show_graph = 1.0
        v_r_X = self.p_X_init
        v_r_S = self.p_S_init
        
        #assemble initial values to array and store them 
        self.initialValues = array([v_r_S, v_r_X, ], 'float64')
        self.stateVectorLen = len(self.initialValues) 
        #put algebraic variables into array, only to compute its size 
        algVars = array([v_r_mu, v_r_STY, v_r_D, ], 'float64')
        self.algVectorLen = len(algVars) 
        #Create maping between variable names and array indices 
        self.variableNameMap = {'r.S':0, 'r.X':1, 'r.mu':2, 'r.STY':3, 'r.D':4, }


    def dynamic(self, time, state, returnAlgVars=False): 
        ''' 
        Compute time derivative of state variables. 
        This function will be called by the solver repeatedly. 
        ''' 
        #take the state variables out of the state vector 
        v_r_S = state[0] 
        v_r_X = state[1] 
        #do computations 
        if v_r_X < self.p_Sf*self.p_Yxs*0.9:
            v_r_D = 0.0
        else: 
            v_r_D = self.p_D_fin
        if v_r_S > 0.0:
            v_r_mu = self.p_mu_max*v_r_S/(v_r_S + self.p_Ks)
        else: 
            v_r_mu = 0.0
        v_r_X_dt = v_r_mu*v_r_X - v_r_D*v_r_X
        v_r_S_dt =  -1.0/self.p_Yxs*v_r_mu*v_r_X + v_r_D*self.p_Sf - v_r_D*v_r_S - self.p_ms*v_r_X
        v_r_STY = v_r_X*v_r_D
        
        if returnAlgVars: 
            #put algebraic variables into array 
            algVars = array([v_r_mu, v_r_STY, v_r_D, ], 'float64')
            return algVars 
        else: 
            #assemble the time derivatives into the return vector 
            stateDt = array([v_r_S_dt, v_r_X_dt, ], 'float64')
            return stateDt 


    def final(self): 
        ''' 
        Display and save simulation results. 
        This function will be called once; after the simulation results 
        have been computed. 
        ''' 
        #the final method's statements 
        if self.p_show_graph != 0.0:
            self.graph(['r.mu', 'r.X', 'r.S', ], 'ContiSmartStart') 
            self.graph(['r.D', 'r.mu', ], 'ContiSmartStart') 
        else: 
            pass 
        print 'simulation ContiSmartStart finished.'
        




#Main function - executed when file (module) runs as an independent program.
#When file is imported into other programs, if-condition is false.
if __name__ == '__main__':
    simulatorClasses = [Batch, Conti, ContiSmartStart, ]
    simulatorMainFunc(simulatorClasses) #in module simulatorbase

