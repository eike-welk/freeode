<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<?xml-stylesheet href="theme/style.css" type="text/css"?>
<head>
<!-- Generated by the Spirit (http://spirit.sf.net) QuickDoc -->
<title>expression_grammar</title>
<link rel="stylesheet" href="theme/style.css" type="text/css"/>
<link rel="prev" href="function_grammar.html"/>
<link rel="next" href="binary_op_parser.html"/>
</head>
<body>
<table class="title" width="100%" border="0" cellspacing="2">
  <tr>
    <td>
expression_grammar    </td>
    <td style="text-align: right;"><a href="http://spirit.sourceforge.net"><img alt="SPIRIT" src="theme/spirit.gif" ></img></a></td>
  </tr>
</table>
<table style="margin-top: 10px;">
  <tr>
    <td><a href="../index.html"><img alt="TOP" src="theme/u_arr.gif"></img></a></td>
    <td><a href="function_grammar.html"><img alt="PREVIOUS" src="theme/l_arr.gif"></img></a></td>
    <td><a href="binary_op_parser.html"><img alt="NEXT" src="theme/r_arr.gif"></img></a></td>
   </tr>
</table>
<p>
We've dealt with the parts of the parser that make <b>YAC</b> a <i>programmable</i>
calculator. Time now to return to the grammar that parses the right hand side
of these statements. The <a href="grammar_overview.html#expression">
grammar</a> governing
these expressions is rather complex. Nonetheless, many of the rules are of the
same form</p>
<pre><code>
    rule1 ::= rule2 (operator_list rule2)* </code></pre><p>
and the semantic actions applied after such a statement is parsed successfully
are also similar in form. If this were &quot;normal&quot; code, we'd try and factor
things into a function and invoke it multiple times, once for each grammar
snippet. </p>
<p>
Of course, this isn't &quot;normal&quot; code. For one thing, <a href="http://spirit.sourceforge.net">
Spirit</a>'s <tt>rule</tt>'s cannot
be copied, so returning the resulting expression from a function is not
possible. Nonetheless, <a href="http://spirit.sourceforge.net">
Spirit</a> does indeed possess the tool for the job. It's
called the <tt>functor_parser</tt>. Before revealing this jewel, however, let's
consider the rules at the hard end, <tt>number</tt> and <tt>function</tt>. After all, it's
these that we end up operating <i>on</i>.</p>
<p>
Parsing a number, a variable or a function call all result in the creation of a
new node on the computational stack. For example:</p>
<pre><code>
    <span class="identifier">number
        </span><span class="special">= </span><span class="identifier">real_p
          </span><span class="special">[
              </span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">number</span><span class="special">.</span><span class="identifier">stk</span><span class="special">, </span><span class="identifier">new_</span><span class="special">&lt;</span><span class="identifier">const_value_node</span><span class="special">&gt;(</span><span class="identifier">arg1</span><span class="special">))
          </span><span class="special">]
        </span><span class="special">| </span><span class="identifier">self</span><span class="special">.</span><span class="identifier">local_vars
          </span><span class="special">[
              </span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">number</span><span class="special">.</span><span class="identifier">stk</span><span class="special">,
                        </span><span class="identifier">new_</span><span class="special">&lt;</span><span class="identifier">variable_node</span><span class="special">&gt;(</span><span class="identifier">address_of</span><span class="special">(</span><span class="identifier">arg1</span><span class="special">)))
          </span><span class="special">]
        </span><span class="special">| </span><span class="identifier">self</span><span class="special">.</span><span class="identifier">global_vars
          </span><span class="special">[
              </span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">number</span><span class="special">.</span><span class="identifier">stk</span><span class="special">,
                        </span><span class="identifier">new_</span><span class="special">&lt;</span><span class="identifier">variable_node</span><span class="special">&gt;(</span><span class="identifier">address_of</span><span class="special">(</span><span class="identifier">arg1</span><span class="special">)))
          </span><span class="special">]
        </span><span class="special">;
</span></code></pre>
<p>
a number or a variable found in one of the variable symbol tables causes a node
to be pushed onto the stack closure variable attached to the <tt>number</tt>
rule. Note that the <tt>variable_node</tt> constructor takes a <i>pointer</i> to the data
stored in the symbol table. <tt>address_of</tt> is a lazy function that that
effectively wraps <tt>&amp;arg1</tt>.</p>
<p>
Thereafter, the stack closure attached to <tt>number</tt> is pushed up the cascade of
rules that govern the grammar in its entirety, eventually reaching the <tt>top</tt>
where it is assigned to the closure that is 'returned' from the
<tt>expression_grammar</tt> itself: </p>
<pre><code>
    <span class="identifier">top </span><span class="special">= </span><span class="identifier">expr</span><span class="special">[</span><span class="identifier">self</span><span class="special">.</span><span class="identifier">stk </span><span class="special">= </span><span class="identifier">arg1</span><span class="special">];

    </span><span class="comment">// a whole heap of intervening rules whose form
    // is similar to that of mult_expr.

    </span><span class="identifier">mult_expr 
        </span><span class="special">=  </span><span class="identifier">expr_atom</span><span class="special">[ </span><span class="identifier">mult_expr</span><span class="special">.</span><span class="identifier">stk </span><span class="special">= </span><span class="identifier">arg1 </span><span class="special">] 
        </span><span class="special">&gt;&gt; </span><span class="literal">'*' 
        </span><span class="special">&gt;&gt; </span><span class="identifier">expr_atom</span><span class="special">[ </span><span class="identifier">mult_expr</span><span class="special">.</span><span class="identifier">stk </span><span class="special">+= </span><span class="identifier">arg1</span><span class="special">, 
                      </span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">mult_expr</span><span class="special">.</span><span class="identifier">stk</span><span class="special">, 
                                </span><span class="comment">/* function node pointing to &quot;mult#2&quot; */</span><span class="special">)
                    </span><span class="special">]
        </span><span class="special">;

    </span><span class="identifier">expr_atom
        </span><span class="special">= </span><span class="identifier">number
          </span><span class="special">[
              </span><span class="identifier">expr_atom</span><span class="special">.</span><span class="identifier">stk </span><span class="special">= </span><span class="identifier">arg1
          </span><span class="special">]
        </span><span class="special">| </span><span class="identifier">func
          </span><span class="special">[
              </span><span class="identifier">expr_atom</span><span class="special">.</span><span class="identifier">stk </span><span class="special">= </span><span class="identifier">arg1
          </span><span class="special">]
        </span><span class="special">| </span><span class="special">...
        </span><span class="special">;
</span></code></pre>
<p>
On each step back up the stack, the stack attached to each rule is created from
the contributions 'returned' from the rules below. What could be easier?</p>
<p>
Turn now to the <tt>func</tt> rule that is used to parse a function call. Parsing a
function call such as <tt>foo(1+2,bar(3,4))</tt> is a little more complicated than
just recognizing a variable <tt>x</tt>. After all, it is the symbol tables of
previously declared variables that do all the work for us there. Here, we must
first generate the mangled name that is used to identify a function in the
symbol table of known functions. This mangling requires the raw function name,
here &quot;foo&quot;, and the function arity, here 2, to generate the mangled name. Once
again, closures attached to the <tt>func</tt> rule make it easy to assemble the
constituent parts:</p>
<pre><code>
    <span class="identifier">func
        </span><span class="special">=  </span><span class="identifier">name
           </span><span class="special">[
               </span><span class="identifier">func</span><span class="special">.</span><span class="identifier">arity </span><span class="special">= </span><span class="number">0</span><span class="special">,
               </span><span class="identifier">func</span><span class="special">.</span><span class="identifier">name </span><span class="special">= </span><span class="identifier">construct_</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;(</span><span class="identifier">arg1</span><span class="special">, </span><span class="identifier">arg2</span><span class="special">)
           </span><span class="special">]
        </span><span class="special">&gt;&gt; </span><span class="special">(</span><span class="literal">'(' </span><span class="special">&gt;&gt; </span><span class="special">!</span><span class="identifier">list_p</span><span class="special">(</span><span class="identifier">arg</span><span class="special">, </span><span class="literal">','</span><span class="special">) </span><span class="special">&gt;&gt; </span><span class="literal">')'</span><span class="special">)
        </span><span class="special">;

    </span><span class="identifier">arg
        </span><span class="special">= </span><span class="identifier">expr
          </span><span class="special">[
              </span><span class="identifier">func</span><span class="special">.</span><span class="identifier">arity </span><span class="special">+= </span><span class="number">1</span><span class="special">,
              </span><span class="identifier">func</span><span class="special">.</span><span class="identifier">stk </span><span class="special">+= </span><span class="identifier">arg1
          </span><span class="special">]
        </span><span class="special">;
</span></code></pre>
<p>
where <tt>name</tt> is a <tt>name_grammar</tt> variable and <tt>expr</tt> is the topmost rule
governing an expression. (Any such expression is valid in the function
argument list.) Having accumulated all this data, we're now in a position to
ascertain whether the function is known:</p>
<pre><code>
    <span class="identifier">func
        </span><span class="special">=  </span><span class="special">...
        </span><span class="special">&gt;&gt; </span><span class="special">(</span><span class="literal">'(' </span><span class="special">&gt;&gt; </span><span class="special">!</span><span class="identifier">list_p</span><span class="special">(</span><span class="identifier">arg</span><span class="special">, </span><span class="literal">','</span><span class="special">) </span><span class="special">&gt;&gt; </span><span class="literal">')'</span><span class="special">)
           </span><span class="special">[
               </span><span class="identifier">func</span><span class="special">.</span><span class="identifier">func_ptr
                   </span><span class="special">= </span><span class="identifier">checked_find_</span><span class="special">(</span><span class="identifier">var</span><span class="special">(</span><span class="identifier">self</span><span class="special">.</span><span class="identifier">functions</span><span class="special">),
                                   </span><span class="identifier">mangled_name</span><span class="special">(</span><span class="identifier">func</span><span class="special">.</span><span class="identifier">name</span><span class="special">, </span><span class="identifier">func</span><span class="special">.</span><span class="identifier">arity</span><span class="special">))
           </span><span class="special">]
</span></code></pre>
<p>
<tt>checked_find_</tt> returning a <tt>shared_ptr</tt> copy of the appropriate entry in the
symbol table. If the function is not found, <tt>checked_find_</tt> returns an empty
<tt>shared_ptr</tt>.</p>
<p>
Finally, we use <a href="http://spirit.sourceforge.net">
Spirit</a>'s 
<tt>if_p(condition)[then-parser].else_p[else-parser]</tt>
utility to either add a node to the computational stack or cause the parser to
fail:</p>
<pre><code>
        <span class="special">...
        </span><span class="special">&gt;&gt; </span><span class="identifier">if_p</span><span class="special">(</span><span class="identifier">func</span><span class="special">.</span><span class="identifier">func_ptr </span><span class="special">!= </span><span class="identifier">function_ptr_t</span><span class="special">())
           </span><span class="special">[
               </span><span class="identifier">epsilon_p
               </span><span class="special">[
                   </span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">func</span><span class="special">.</span><span class="identifier">stk</span><span class="special">,
                             </span><span class="identifier">new_</span><span class="special">&lt;</span><span class="identifier">sys_function_node</span><span class="special">&gt;(</span><span class="identifier">func</span><span class="special">.</span><span class="identifier">func_ptr</span><span class="special">))
               </span><span class="special">]
           </span><span class="special">]
          </span><span class="special">.</span><span class="identifier">else_p</span><span class="special">[</span><span class="identifier">nothing_p</span><span class="special">]
        </span><span class="special">;
</span></code></pre>
<p>
Note that this block doesn't actually consume any more input data.</p>
<table style="margin-top: 10px;">
  <tr>
    <td><a href="../index.html"><img alt="TOP" src="theme/u_arr.gif"></img></a></td>
    <td><a href="function_grammar.html"><img alt="PREVIOUS" src="theme/l_arr.gif"></img></a></td>
    <td><a href="binary_op_parser.html"><img alt="NEXT" src="theme/r_arr.gif"></img></a></td>
   </tr>
</table>
<hr/>
<p>
  <a href="http://validator.w3.org/check/referer">
    <img style="border:0;width:88px;height:31px"
      src="theme/valid-xhtml11.png"
      alt="Valid XHTML 1.1!" />
  </a>
  <a href="http://jigsaw.w3.org/css-validator/check/referer">
    <img style="border:0;width:88px;height:31px"
      src="theme/vcss.png"
      alt="Valid CSS!" />
  </a>
</p>
<p class="copyright">

  Copyright &copy; 2004 Angus Leeming<br/><br/>
  Distributed under the Boost Software License,
  Version 1.0. (See accompanying file
  <a href="../LICENSE_1_0.txt">LICENSE_1_0.txt</a> or copy at
  <a href="http://www.boost.org/LICENSE_1_0.txt">
     http://www.boost.org/LICENSE_1_0.txt
  </a>)

</p>
</body>
</html>
