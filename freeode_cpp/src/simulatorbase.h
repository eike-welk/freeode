//This file was generated by the script "py2c_string".

"\n"
"\n"
"from scipy import * # Also includes Numeric.\n"
"import Gnuplot, Gnuplot.funcutils # @todo switch to a more well known graphics library\n"
"\n"
"\n"
"class SimulatorBase:\n"
"    \"\"\" Base class for the generated simulator classes \"\"\"\n"
"\n"
"    def __init__(self):\n"
"         #Show if initial values have been computed\n"
"##        self._initialValuesDirty = True\n"
"        pass\n"
"\n"
"    def clear(self):\n"
"        \"\"\"\n"
"        Delete the time and the result array.\n"
"        \"\"\"\n"
"        if hasattr(self, 'time'):\n"
"            del self.time\n"
"        if hasattr(self, '_resultArray'):\n"
"            del self._resultArray\n"
"\n"
"    def get(self, varName):\n"
"        \"\"\"\n"
"        Get a variable by name.\n"
"\n"
"        @todo add returning multiple variables at once\n"
"\n"
"        There are special variable names:\n"
"           'time': vector of times\n"
"           'all': array of all variables\n"
"        \"\"\"\n"
"        if varName == 'time':\n"
"            return self.time\n"
"        elif varName == 'all':\n"
"            return self._resultArray\n"
"        index = self._resultArrayMap[varName]\n"
"        return self._resultArray[:,index]\n"
"\n"
"    def graph(self, varNames):\n"
"        \"\"\"\n"
"        Show one or several variables in a graph.\n"
"\n"
"        Parameters:\n"
"           varNames: String with a list of variables to be plotted. (Space or comma seperated.)\n"
"                     e.g.: 'X mu'\n"
"            \n"
"        @todo there must be an error when the variable name is wrong.\n"
"        \"\"\"\n"
"\n"
"        diagram=Gnuplot.Gnuplot(debug=0, persist=1)\n"
"        diagram('set data style lines')\n"
"        diagram.title(varNames)\n"
"        diagram.xlabel('Time')\n"
"\n"
"        varList = varNames.replace(',', ' ').split(' ')\n"
"        for varName1 in varList:\n"
"            if not (varName1 in self._resultArrayMap): \n"
"                print('Error unknown variable name: %s') % varName1\n"
"                continue\n"
"                \n"
"            curve=Gnuplot.Data(self.get('time'), self.get(varName1))\n"
"            diagram.replot(curve)\n"
"\n"
"    def simulateDynamic(self):\n"
"        \"\"\"\n"
"        This function performs the simulation.\n"
"        \"\"\"\n"
"\n"
"##        #The numerical integration changes the initial values, but the user maybe \n"
"##        #wants to compute them in advance\n"
"##        if self._initialValuesDirty :\n"
"##            #Compute the initial values. (They are overwritten by integrate.odeint)\n"
"##            self._initialValues = self.setInitialValues()\n"
"##        self._initialValuesDirty = True;\n"
"        \n"
"        #Compute the initial values. (They are overwritten by integrate.odeint)\n"
"        initialValues = self.setInitialValues()\n"
"        #create the array of output time points\n"
"        self.time = linspace(0.0, self.simulationTime, self.simulationTime/self.reportingInterval + 1) #note: no rounding is better, linspace is quite smart.\n"
"        #compute the numerical solution\n"
"        y = integrate.odeint(self._diffStateT, initialValues, self.time)\n"
"        #compute the algebraic variables for a second time, so they can be shown in graphs.\n"
"        self._resultArray = self._outputEquations(y)\n"
"\n"
"    def simulateSteadyState(self):\n"
"        \"\"\"\n"
"        This function computes a steady state solution. And appends it to the \n"
"        array of results. \n"
"        Initial guess: When there are no prior results the initial valuse are\n"
"        (ab)used as a initial guess; otherwise the latest results are used as \n"
"        the initial guess.\n"
"        In the time array the count of current simulation is stored. This way the \n"
"        graph function still gives useful results with steady state simulations.\n"
"        \"\"\"\n"
"        \n"
"        if not hasattr(self, 'time'):\n"
"            #this is the first call in a row of steady state simulations - setup everything\n"
"            lastResult = -1\n"
"            self._resultArray = array([[0]], Float)\n"
"            self.time = array([0], Float)\n"
"            x0 = self.setInitialValues()    #initial guess for root finder: initial values abused\n"
"            t0 = -1\n"
"        else:\n"
"            lastResult = shape(self._resultArray)[0]-1\n"
"            x0 = self._resultArray[lastResult, 0:self._numStates] #initial guess for root finder: last result\n"
"            t0 = self.time[lastResult] \n"
"        \n"
"        #compute the state variables of the steady state solution\n"
"        (xmin, msg) = optimize.leastsq(self._diffStateT, x0, (0))\n"
"        #also compute the algebraic variables\n"
"        currRes = self._outputEquations(xmin)\n"
"        #expand the storage and save the results\n"
"        self._resultArray = resize(self._resultArray, (lastResult+2, self._numVariables))\n"
"        self._resultArray[lastResult+1,:] = currRes[0,:]\n"
"        self.time = resize(self.time, (lastResult+2,))\n"
"        self.time[lastResult+1] = t0 + 1\n"
"\n"
"\n"
