<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<?xml-stylesheet href="theme/style.css" type="text/css"?>
<head>
<!-- Generated by the Spirit (http://spirit.sf.net) QuickDoc -->
<title>binary_op_parser</title>
<link rel="stylesheet" href="theme/style.css" type="text/css"/>
<link rel="prev" href="expression_grammar.html"/>
<link rel="next" href="the_end.html"/>
</head>
<body>
<table class="title" width="100%" border="0" cellspacing="2">
  <tr>
    <td>
binary_op_parser    </td>
    <td style="text-align: right;"><a href="http://spirit.sourceforge.net"><img alt="SPIRIT" src="theme/spirit.gif" ></img></a></td>
  </tr>
</table>
<table style="margin-top: 10px;">
  <tr>
    <td><a href="../index.html"><img alt="TOP" src="theme/u_arr.gif"></img></a></td>
    <td><a href="expression_grammar.html"><img alt="PREVIOUS" src="theme/l_arr.gif"></img></a></td>
    <td><a href="the_end.html"><img alt="NEXT" src="theme/r_arr.gif"></img></a></td>
   </tr>
</table>
<p>
That's pretty much all there is to <b>YAC</b>. All the logic needed to write such a
utility has been laid bare. However, before saying &quot;good night&quot; there is time
for one last introduction: the <tt>functor_parser</tt>. The Functor Parser pages in
the <a href="http://spirit.sourceforge.net">
Spirit</a> documentation don't really give much idea of the power of this
tool. That's a shame because it can be used as the <a href="http://spirit.sourceforge.net">
Spirit</a> equivalent of a
function call to refactor needlessly repetitive chunks of parser code.</p>
<p>
First, return to the <a href="http://spirit.sourceforge.net">
Spirit</a> code used to parse a multiplication:</p>
<pre><code>
    <span class="identifier">mult_expr 
        </span><span class="special">=  </span><span class="identifier">expr_atom</span><span class="special">[ </span><span class="identifier">mult_expr</span><span class="special">.</span><span class="identifier">stk </span><span class="special">= </span><span class="identifier">arg1 </span><span class="special">] 
        </span><span class="special">&gt;&gt; </span><span class="literal">'*' 
        </span><span class="special">&gt;&gt; </span><span class="identifier">expr_atom</span><span class="special">[ </span><span class="identifier">mult_expr</span><span class="special">.</span><span class="identifier">stk </span><span class="special">+= </span><span class="identifier">arg1</span><span class="special">, 
                      </span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">mult_expr</span><span class="special">.</span><span class="identifier">stk</span><span class="special">, 
                                </span><span class="comment">/* function node pointing to &quot;mult#2&quot; */</span><span class="special">)
                    </span><span class="special">]
        </span><span class="special">;
</span></code></pre>
<p>
The code is pretty straightforward, but these rules all have a similar form and
they all lead to a similar set of semantic actions:</p>
<pre><code>
    bitwise_expr  ::= equality_expr (('&amp;' | '|' | '^') equality_expr)*
    equality_expr ::= compare_expr  ((&quot;==&quot; | &quot;!=&quot;) compare_expr)*
    compare_expr  ::= shift_expr    (('&lt;' | '&gt;' | &quot;&lt;=&quot; | &quot;&gt;=&quot;) shift_expr)*
    shift_expr    ::= add_expr      ((&quot;&lt;&lt;&quot; | &quot;&gt;&gt;&quot;) add_expr)*
    add_expr      ::= mult_expr     (('+' | '-') mult_expr)*
    mult_expr     ::= expr_atom     (('*' | '/' | '%') expr_atom)* </code></pre><p>
Clearly, writing out <tt>mult_expr</tt> six times won't make the grammar any easier
to read. (In fact, the <tt>mult_expr</tt> above is a simplification. The actual code
is even more ugly.) It would be great if the grammar statement could be turned
into this code: </p>
<pre><code>
    <span class="identifier">bitwise_expr
        </span><span class="special">= </span><span class="identifier">binary_op_p</span><span class="special">(</span><span class="identifier">equality_expr</span><span class="special">, </span><span class="identifier">bitwise_op</span><span class="special">)[</span><span class="identifier">bitwise_expr</span><span class="special">.</span><span class="identifier">stk </span><span class="special">= </span><span class="identifier">arg1</span><span class="special">];

    </span><span class="identifier">equality_expr
        </span><span class="special">= </span><span class="identifier">binary_op_p</span><span class="special">(</span><span class="identifier">compare_expr</span><span class="special">, </span><span class="identifier">equality_op</span><span class="special">)[</span><span class="identifier">equality_expr</span><span class="special">.</span><span class="identifier">stk </span><span class="special">= </span><span class="identifier">arg1</span><span class="special">];

    </span><span class="identifier">compare_expr
        </span><span class="special">= </span><span class="identifier">binary_op_p</span><span class="special">(</span><span class="identifier">shift_expr</span><span class="special">, </span><span class="identifier">compare_op</span><span class="special">)[</span><span class="identifier">compare_expr</span><span class="special">.</span><span class="identifier">stk </span><span class="special">= </span><span class="identifier">arg1</span><span class="special">];

    </span><span class="identifier">shift_expr
        </span><span class="special">= </span><span class="identifier">binary_op_p</span><span class="special">(</span><span class="identifier">add_expr</span><span class="special">, </span><span class="identifier">shift_op</span><span class="special">)[</span><span class="identifier">shift_expr</span><span class="special">.</span><span class="identifier">stk </span><span class="special">= </span><span class="identifier">arg1</span><span class="special">];

    </span><span class="identifier">add_expr
        </span><span class="special">= </span><span class="identifier">binary_op_p</span><span class="special">(</span><span class="identifier">mult_expr</span><span class="special">, </span><span class="identifier">add_op</span><span class="special">)[ </span><span class="identifier">add_expr</span><span class="special">.</span><span class="identifier">stk </span><span class="special">= </span><span class="identifier">arg1 </span><span class="special">];

    </span><span class="identifier">mult_expr
        </span><span class="special">= </span><span class="identifier">binary_op_p</span><span class="special">(</span><span class="identifier">expr_atom</span><span class="special">, </span><span class="identifier">mult_op</span><span class="special">)[ </span><span class="identifier">mult_expr</span><span class="special">.</span><span class="identifier">stk </span><span class="special">= </span><span class="identifier">arg1 </span><span class="special">];
</span></code></pre>
<p>
And, indeed, thanks to the <tt>functor_parser</tt> that's exactly how it <i>does</i>
<a href="../src/yac_expression_grammar.hpp">
appear</a>.</p>
<p>
The <tt>binary_op_p</tt> parser takes two arguments, the second of which is a
symbol table containing pointers to the functions representing the appropriate
set of operations (<tt>'+' | '-'</tt> etc.). That's just a <b>YAC</b> implentation
detail. What is interesting is that <tt>binary_op_p</tt> is a fully-fledged parser
whose 'result' (here the result is a <tt>stack</tt> variable) can be assigned to the
parent rule's closure. The result is clear, easy to maintain code.</p>
<p>
The <tt>binary_op_p</tt> has three components:</p>
<p>
1. <tt>struct binary_op_parser</tt> is a class template that stores two parsers,
created from the two rules passed to its constructor.
It also defines a <tt>result_t</tt> typedef which in this instance is a <tt>stack</tt>.
The parser is invoked through the class' <tt>operator()</tt> to fill a <tt>result</tt>
variable and to also return the number of characters parsed to the invoking
routine. That is, it's public interface is:</p>
<pre><code>
    <span class="keyword">template </span><span class="special">&lt;</span><span class="keyword">typename </span><span class="identifier">TermT</span><span class="special">, </span><span class="keyword">typename </span><span class="identifier">OpT</span><span class="special">&gt;
    </span><span class="keyword">struct </span><span class="identifier">binary_op_parser </span><span class="special">{

        </span><span class="identifier">binary_op_parser</span><span class="special">(</span><span class="identifier">TermT </span><span class="keyword">const </span><span class="special">&amp; </span><span class="identifier">term_</span><span class="special">, </span><span class="identifier">OpT </span><span class="keyword">const </span><span class="special">&amp; </span><span class="identifier">op_table_</span><span class="special">);

        </span><span class="keyword">typedef </span><span class="identifier">stack </span><span class="identifier">result_t</span><span class="special">;

        </span><span class="keyword">template </span><span class="special">&lt;</span><span class="keyword">typename </span><span class="identifier">ScannerT</span><span class="special">&gt;
        </span><span class="identifier">std</span><span class="special">::</span><span class="identifier">ptrdiff_t
        </span><span class="keyword">operator</span><span class="special">()(</span><span class="identifier">ScannerT </span><span class="keyword">const </span><span class="special">&amp; </span><span class="identifier">scan</span><span class="special">, </span><span class="identifier">result_t </span><span class="special">&amp; </span><span class="identifier">result</span><span class="special">) </span><span class="keyword">const
    </span><span class="special">};
</span></code></pre>
<p>
The actual code is to be found <a href="../src/yac_binary_op_parser.hpp">
here</a>. Other
code describing the approach is to be found in functor_parser.html in the
spirit docs.</p>
<p>
2. <tt>struct binary_op_parser_gen</tt> has a template <tt>operator()</tt> which generates a
conformant <a href="http://spirit.sourceforge.net">
Spirit</a> parser from the two arguments passed to it.
 The return type of this <tt>operator()</tt> looks pretty hairy at first sight,
but actually it's saying no more than  that the <tt>rule</tt> and symbol table passed
to the <tt>operator()</tt> must be converted to parsers if they are to be stored by
the <tt>binary_op_parser</tt> class template that does the actual work:</p>
<pre><code>
    <span class="keyword">template </span><span class="special">&lt;</span><span class="keyword">typename </span><span class="identifier">TermT</span><span class="special">, </span><span class="keyword">typename </span><span class="identifier">OpT</span><span class="special">&gt;
    </span><span class="identifier">spirit</span><span class="special">::</span><span class="identifier">functor_parser</span><span class="special">&lt;
	</span><span class="identifier">binary_op_parser</span><span class="special">&lt;
            </span><span class="keyword">typename </span><span class="identifier">spirit</span><span class="special">::</span><span class="identifier">as_parser</span><span class="special">&lt;</span><span class="identifier">TermT</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">,
            </span><span class="keyword">typename </span><span class="identifier">spirit</span><span class="special">::</span><span class="identifier">as_parser</span><span class="special">&lt;</span><span class="identifier">OpT</span><span class="special">&gt;::</span><span class="identifier">type
        </span><span class="special">&gt;
    </span><span class="special">&gt;
    </span><span class="keyword">operator</span><span class="special">()(</span><span class="identifier">TermT </span><span class="keyword">const </span><span class="special">&amp; </span><span class="identifier">term</span><span class="special">, </span><span class="identifier">OpT </span><span class="keyword">const </span><span class="special">&amp; </span><span class="identifier">op_table</span><span class="special">) </span><span class="keyword">const</span><span class="special">;
</span></code></pre>
<p>
3. <tt>binary_op_p</tt> is a concrete instantiation of this <tt>binary_op_parser_gen</tt>
struct. All of the <a href="http://spirit.sourceforge.net">
Spirit</a> parsers that we're now so familiar with are built in
a similar way to <tt>binary_op_p</tt>.</p>
<table style="margin-top: 10px;">
  <tr>
    <td><a href="../index.html"><img alt="TOP" src="theme/u_arr.gif"></img></a></td>
    <td><a href="expression_grammar.html"><img alt="PREVIOUS" src="theme/l_arr.gif"></img></a></td>
    <td><a href="the_end.html"><img alt="NEXT" src="theme/r_arr.gif"></img></a></td>
   </tr>
</table>
<hr/>
<p>
  <a href="http://validator.w3.org/check/referer">
    <img style="border:0;width:88px;height:31px"
      src="theme/valid-xhtml11.png"
      alt="Valid XHTML 1.1!" />
  </a>
  <a href="http://jigsaw.w3.org/css-validator/check/referer">
    <img style="border:0;width:88px;height:31px"
      src="theme/vcss.png"
      alt="Valid CSS!" />
  </a>
</p>
<p class="copyright">

  Copyright &copy; 2004 Angus Leeming<br/><br/>
  Distributed under the Boost Software License,
  Version 1.0. (See accompanying file
  <a href="../LICENSE_1_0.txt">LICENSE_1_0.txt</a> or copy at
  <a href="http://www.boost.org/LICENSE_1_0.txt">
     http://www.boost.org/LICENSE_1_0.txt
  </a>)

</p>
</body>
</html>
