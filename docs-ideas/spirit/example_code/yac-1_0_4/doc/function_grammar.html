<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<?xml-stylesheet href="theme/style.css" type="text/css"?>
<head>
<!-- Generated by the Spirit (http://spirit.sf.net) QuickDoc -->
<title>function_grammar</title>
<link rel="stylesheet" href="theme/style.css" type="text/css"/>
<link rel="prev" href="variable_grammar.html"/>
<link rel="next" href="expression_grammar.html"/>
</head>
<body>
<table class="title" width="100%" border="0" cellspacing="2">
  <tr>
    <td>
function_grammar    </td>
    <td style="text-align: right;"><a href="http://spirit.sourceforge.net"><img alt="SPIRIT" src="theme/spirit.gif" ></img></a></td>
  </tr>
</table>
<table style="margin-top: 10px;">
  <tr>
    <td><a href="../index.html"><img alt="TOP" src="theme/u_arr.gif"></img></a></td>
    <td><a href="variable_grammar.html"><img alt="PREVIOUS" src="theme/l_arr.gif"></img></a></td>
    <td><a href="expression_grammar.html"><img alt="NEXT" src="theme/r_arr.gif"></img></a></td>
   </tr>
</table>
<p>
Consider what should happen when the parser encounters expressions
such as:</p>
<pre><code>
    axpy(a,x,y) = a * x + y
    factorial(x) = (x &lt; 0.1) ? 1 : x * factorial(x - 1) </code></pre><p>
The symbol table of recognized functions should be updated and a stack
representation of the function assignment should be generated, much as
occurs when a <a href="variable_grammar.html">
variable expression</a> is
encountered. For example, the stack representation of <tt>axpy(a,x,y)=a*x+y</tt> is</p>
<pre><code>
    0    variable_node    a
    1    variable_node    x
    2    function_node    mult
    3    variable_node    y
    4    function_node    add
    5    func_def_node    axpy#3
</code></pre><p>
where <tt>axpy#3</tt> is the mangled name of the <tt>axpy</tt> function taking 3
arguments. All these nodes contain pointers to the appropriate entries in the
various symbol tables.</p>
<p>
Separate actions for function declaration and function
definition are required if <b>YAC</b> is to have the ability to re-define
functions dynamically. That is, the function definition should be
assigned to the function only in the course of evaluating the
computational stack.</p>
<h1><a id="public_interface_of_function_grammar"></a>Public interface of function_grammar</h1><p>
The similar requirements of <tt>function_grammar</tt> and
<tt>variable_grammar</tt> mean that their public interfaces are also very
similar. The only difference lies in which symbol table is <tt>const</tt> and
which is <tt>non-const</tt>:</p>
<pre><code>
    <span class="keyword">namespace </span><span class="identifier">yac </span><span class="special">{

    </span><span class="keyword">struct </span><span class="identifier">function_grammar
        </span><span class="special">: </span><span class="identifier">grammar</span><span class="special">&lt;</span><span class="identifier">function_grammar</span><span class="special">, </span><span class="identifier">stack_closure</span><span class="special">::</span><span class="identifier">context_t</span><span class="special">&gt;
    </span><span class="special">{
        </span><span class="keyword">typedef </span><span class="identifier">symbols</span><span class="special">&lt;</span><span class="identifier">shared_ptr</span><span class="special">&lt;</span><span class="identifier">function_node</span><span class="special">&gt; </span><span class="special">&gt; </span><span class="identifier">function_table_t</span><span class="special">;
        </span><span class="keyword">typedef </span><span class="identifier">symbols</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt; </span><span class="identifier">var_table_t</span><span class="special">;

        </span><span class="identifier">function_table_t </span><span class="special">&amp; </span><span class="identifier">functions</span><span class="special">;
        </span><span class="identifier">var_table_t </span><span class="keyword">const </span><span class="special">&amp; </span><span class="identifier">global_vars</span><span class="special">;

        </span><span class="identifier">function_grammar</span><span class="special">(</span><span class="identifier">function_table_t </span><span class="special">&amp; </span><span class="identifier">f</span><span class="special">, </span><span class="identifier">var_table_t </span><span class="keyword">const </span><span class="special">&amp; </span><span class="identifier">v</span><span class="special">)
            </span><span class="special">: </span><span class="identifier">functions</span><span class="special">(</span><span class="identifier">f</span><span class="special">), </span><span class="identifier">global_vars</span><span class="special">(</span><span class="identifier">v</span><span class="special">)
        </span><span class="special">{}

        </span><span class="keyword">template </span><span class="special">&lt;</span><span class="keyword">typename </span><span class="identifier">ScannerT</span><span class="special">&gt;
        </span><span class="keyword">struct </span><span class="identifier">definition</span><span class="special">;
    </span><span class="special">};

    </span><span class="special">} </span><span class="comment">// namespace yac
</span></code></pre>
<h1><a id="user_function"></a>user_function</h1><p>
Before going on to talk about the <tt>definition</tt> struct of <tt>function_grammar</tt>
itself, it is pertinent to ask, &quot;What's in a <tt>function</tt> anyway?&quot; Or rather,
what's in the <tt>user_function</tt> that derives from it? Here, then, are the
interesting parts of its interface:</p>
<pre><code>
    <span class="keyword">namespace </span><span class="identifier">yac </span><span class="special">{

    </span><span class="keyword">struct </span><span class="identifier">user_func_expression </span><span class="special">{
        </span><span class="keyword">typedef </span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">shared_ptr</span><span class="special">&lt;</span><span class="identifier">spirit</span><span class="special">::</span><span class="identifier">symbols</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt; </span><span class="special">&gt; </span><span class="identifier">symbol_table_ptr</span><span class="special">;

        </span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">string</span><span class="special">&gt; </span><span class="identifier">arg_names</span><span class="special">;
        </span><span class="identifier">symbol_table_ptr </span><span class="identifier">local_vars</span><span class="special">;
        </span><span class="identifier">stack </span><span class="identifier">stk</span><span class="special">;
    </span><span class="special">};

    </span><span class="keyword">struct </span><span class="identifier">user_function </span><span class="special">: </span><span class="keyword">public </span><span class="identifier">function
    </span><span class="special">{
        </span><span class="keyword">typedef </span><span class="identifier">spirit</span><span class="special">::</span><span class="identifier">symbols</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt; </span><span class="identifier">symbol_table_t</span><span class="special">;

        </span><span class="identifier">user_function</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string </span><span class="keyword">const </span><span class="special">&amp; </span><span class="identifier">name</span><span class="special">, </span><span class="identifier">size_type </span><span class="keyword">const </span><span class="identifier">function_arity</span><span class="special">);
        </span><span class="identifier">user_function </span><span class="special">&amp; </span><span class="keyword">operator</span><span class="special">=(</span><span class="identifier">user_func_expression </span><span class="keyword">const </span><span class="special">&amp; </span><span class="identifier">ufe</span><span class="special">);

    </span><span class="keyword">private</span><span class="special">:
        </span><span class="keyword">double </span><span class="identifier">eval_priv</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt; </span><span class="keyword">const </span><span class="special">&amp; </span><span class="identifier">params</span><span class="special">) </span><span class="keyword">const</span><span class="special">;

        </span><span class="identifier">size_type </span><span class="identifier">arity_</span><span class="special">;
        </span><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt; </span><span class="identifier">arg_names_</span><span class="special">;
        </span><span class="identifier">symbol_table_t </span><span class="identifier">local_vars_</span><span class="special">;
        </span><span class="identifier">stack </span><span class="identifier">stk_</span><span class="special">;
    </span><span class="special">};

    </span><span class="special">} </span><span class="comment">// namespace yac
</span></code></pre>
<p>
The definition of <tt>eval_priv</tt> has already been presented,
<a href="vm_details.html#perhaps_some_code">
here</a> to explain just how a
<tt>user_function</tt> is evaluated. It was explained that a
<tt>user_function</tt> contains three separate data stores all of which are used when
the function comes to be evaluated for a particular set of input parameters.</p>
<ul><li><tt>local_vars_</tt> is the symbol table of variables whose scope is local to the function. In this simple grammar, these are simply the variables of the function's argument list.</li><li><tt>arg_names_</tt> is used to map the <tt>params</tt> data to the values of these local variables when the function is evaluated.</li><li>Evaluation of the function involves &quot;unwinding&quot; of <tt>stk_</tt> with the aid of the three symbol tables that store the functions, the global and the local variables. These stores are not referenced directly, but <tt>variable_node</tt>s and <tt>function_node</tt>s in <tt>stk_</tt> will contain pointers to their data.</li></ul><p>
Filling the data stores of a <tt>user_function</tt> is a two-stage process. When the
variable is created, at parse time, it's name and arity are
set. Storing this variable, in the symbol table of known functions,
e.g. <tt>aypy#3</tt>, will enable the <tt>expression_grammar</tt> to parse any rhs
<tt>expression</tt> involving <tt>aypy#3</tt> that occurs thereafter. The parsing process
goes on to add a <tt>func_def_node</tt> to the virtual machine's stack, representing
the assignment of the function definition to the function variable. This
assignment occurs when the stack comes to be evaluated, after the parsing is
complete. A <tt>func_def_node</tt> contains two stores: a pointer to the function in
the function symbol table and a <tt>user_func_expression</tt> variable that contains
the three data stores described above.</p>
<p>
The logic behind the above description is, I hope, transparent. What is
interesting from a <a href="http://spirit.sourceforge.net">
Spirit</a> point of view is best explained using the example
function declaration <tt>axpy(a,x,y)=a*x+y</tt>. The <tt>local_vars_</tt> symbol table of
this <tt>user_function</tt> will contain three variables, <tt>a</tt>, <tt>x</tt> and <tt>y</tt>. This
symbol table is created dynamically and will be stored in a
<tt>user_func_expression</tt> in the virtual machine's computational stack. However,
this self-same store <i>should also be made available</i> to the
<tt>expression_grammar</tt> variable tasked with parsing <tt>a*x+y</tt> and generating a
<tt>stack</tt> from it. This requirement will lead to some quite complex use of the
<a href="http://spirit.sourceforge.net">
Spirit</a> parser tools  &#8212;  the <tt>expression_grammar</tt> parser must also be created
dynamically!</p>
<h1><a id="function_grammar__definition"></a>function_grammar::definition</h1><p>
The <a href="http://spirit.sourceforge.net">
Spirit</a> representation of the grammar needed to parse a statement such
as <tt>axpy(a,x,y)=a*x+y</tt> is:</p>
<pre><code>
    <span class="identifier">func_def  
        </span><span class="special">=  </span><span class="identifier">func_decl
           </span><span class="special">[
               </span><span class="comment">// Semantic actions to add the function to
               // the symbol table of known functions.
           </span><span class="special">]
        </span><span class="special">&gt;&gt; </span><span class="literal">'='
           </span><span class="comment">// There is a catch here  &#8212;  expression
           // depends on a dynamically-created local_vars
           // store.
        </span><span class="special">&gt;&gt; </span><span class="identifier">expression
           </span><span class="special">[
               </span><span class="comment">// Semantic actions to build a computational
               // stack that will assign the function definition
               // to the function variable.
           </span><span class="special">]
        </span><span class="special">;
    </span><span class="identifier">func_decl 
        </span><span class="special">= </span><span class="identifier">name </span><span class="special">&gt;&gt; </span><span class="literal">'(' </span><span class="special">&gt;&gt; </span><span class="special">!</span><span class="identifier">name_list </span><span class="special">&gt;&gt; </span><span class="literal">')'</span><span class="special">;
    </span><span class="identifier">name_list 
        </span><span class="special">= </span><span class="identifier">name </span><span class="special">&gt;&gt; </span><span class="special">*(</span><span class="literal">',' </span><span class="special">&gt;&gt; </span><span class="identifier">name</span><span class="special">);
</span></code></pre>
<p>
where <tt>func_decl</tt> is the rule used to parse <tt>axpy(a,x,y)</tt>.</p>
<p>
Clearly, parsing
the input data is quite straight-forward, but the semantic actions that result
are pretty complex. The snippet above illustrates the two-stage nature of the
process of applying these actions. However, before considering them
any further, let's return to the <tt>func_decl</tt> rule itself.</p>
<p>
Three local variables are filled when parsing a function
declaration like <tt>foo(a,b)</tt>, the function name and its argument list which is
used to fill both a vector (so that the parameters passed to the function can
be assigned to the correct local variable) and as a symbol table. Local
variables in the context of a <a href="http://spirit.sourceforge.net">
Spirit</a> parser suggest that a closure should be
attached to <tt>func_decl</tt>:</p>
<pre><code>
    <span class="keyword">struct </span><span class="identifier">func_closure
        </span><span class="special">: </span><span class="identifier">spirit</span><span class="special">::</span><span class="identifier">closure</span><span class="special">&lt;</span><span class="identifier">func_closure</span><span class="special">,
                          </span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,
                          </span><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;,
                          </span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">shared_ptr</span><span class="special">&lt;</span><span class="identifier">spirit</span><span class="special">::</span><span class="identifier">symbols</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt; </span><span class="special">&gt;
    </span><span class="special">{
        </span><span class="identifier">member1 </span><span class="identifier">name</span><span class="special">;
        </span><span class="identifier">member2 </span><span class="identifier">args</span><span class="special">;
        </span><span class="identifier">member3 </span><span class="identifier">local_vars</span><span class="special">;
    </span><span class="special">};
</span></code></pre>
<p>
The local variable symbol table is stored as a shared_ptr to simplify the
accounting process that ensures all pointers to its data from the stack
representing the function definition remain valid.</p>
<p>
An attempt to parse <tt>foo(a,b)</tt> must ensure that this symbol table is
reset for each function parsed. This is done as late as possible (i.e., after
<tt>foo(</tt>), using a lazy function wrapper for <tt>shared_ptr::reset</tt>.</p>
<p>
Thereafter, there is one subtlety that should be considered when parsing a
function declaration like <tt>foo(a,b)</tt>. That is, <tt>foo(a,a)</tt> should be flagged as
invalid, causing the parser to fail. Or in other words, the dynamically created
<tt>func_def.local_vars</tt> closure variable should be used in parsing the function
declaration itself! (Remember, a <a href="http://spirit.sourceforge.net">
Spirit</a> symbol table is a fully fledged parser
in its own right.) Fortunately for us, <a href="http://spirit.sourceforge.net">
Spirit</a> has a rather cool <tt>lazy_p</tt>
parser that fits the bill perfectly. <tt>lazy_p</tt> is a lazy parser; that is, it
can be created dynamically. The final result is:</p>
<pre><code>
    <span class="comment">// This rule parses &quot;foo(a,b)&quot;, disallowing &quot;foo(a,a)&quot;.
    // Note that the closure variables are attached to &quot;func_def&quot;
    // rather than to &quot;func_decl&quot;.
    // That's safe because this grammar is not recursive.
    // &quot;func_def&quot; will go on to use these data to construct the
    // final semantic actions.
    </span><span class="identifier">func_decl
        </span><span class="special">=  </span><span class="identifier">name
           </span><span class="special">[
               </span><span class="identifier">func_def</span><span class="special">.</span><span class="identifier">name </span><span class="special">= </span><span class="identifier">construct_</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;(</span><span class="identifier">arg1</span><span class="special">, </span><span class="identifier">arg2</span><span class="special">)
           </span><span class="special">]
        </span><span class="special">&gt;&gt; </span><span class="identifier">ch_p</span><span class="special">(</span><span class="literal">'('</span><span class="special">)
           </span><span class="special">[
               </span><span class="identifier">reset</span><span class="special">(</span><span class="identifier">func_def</span><span class="special">.</span><span class="identifier">local_vars</span><span class="special">, </span><span class="identifier">new_</span><span class="special">&lt;</span><span class="identifier">var_table_t</span><span class="special">&gt;())
           </span><span class="special">]
        </span><span class="special">&gt;&gt; </span><span class="special">!</span><span class="identifier">list_p</span><span class="special">((</span><span class="identifier">name </span><span class="special">- </span><span class="identifier">lazy_p</span><span class="special">(*</span><span class="identifier">func_def</span><span class="special">.</span><span class="identifier">local_vars</span><span class="special">))
                   </span><span class="special">[
                       </span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">func_def</span><span class="special">.</span><span class="identifier">args</span><span class="special">,
                                 </span><span class="identifier">construct_</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;(</span><span class="identifier">arg1</span><span class="special">, </span><span class="identifier">arg2</span><span class="special">)),
                       </span><span class="identifier">add_symbol</span><span class="special">(*</span><span class="identifier">func_def</span><span class="special">.</span><span class="identifier">local_vars</span><span class="special">,
                                  </span><span class="identifier">construct_</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;(</span><span class="identifier">arg1</span><span class="special">, </span><span class="identifier">arg2</span><span class="special">))
                   </span><span class="special">]
                 </span><span class="special">, </span><span class="literal">','</span><span class="special">)
        </span><span class="special">&gt;&gt; </span><span class="literal">')'</span><span class="special">;
</span></code></pre>
<table class="note_table">
  <tr>
    <td class="note_box">
<img src="theme/alert.gif" alt="ALERT!"></img>
<b><tt>new_</tt> or <tt>new</tt> in semantic actions?</b><br/><br/>

One very important point to note about the call to <tt>reset</tt> is that the data is
created using Phoenix's <tt>new_</tt> lazy function.<br/><br/>

It is possible to use <tt>new var_table_t</tt> here (i.e., the code will compile)
because all the information needed to invoke the <tt>var_table_t</tt> constructor is
available at compile time. However, to do so is almost certainly an
error.<br/><br/>

A call to <tt>new</tt> will create a variable on the heap at compile time. This
variable is then stored until the input data comes to be parsed, whereupon it
is passed to <tt>shared_ptr::reset()</tt>. If more than one function comes to be
parsed, then this variable will be passed more than once  &#8212;  disaster!
    </td>
  </tr>
</table>
<p>
What I hope is gradually becoming clear is that almost all the difficulties
that have been encountered so far have been in specifying exactly what semantic
actions should be performed. Thereafter, <a href="http://spirit.sourceforge.net">
Spirit</a> makes it almost trivially easy
to write the code itself. It really <i>is</i> cool to be Lazy. <img src="theme/smiley.gif" alt=":-)"></img></p>
<p>
This feeling, that the semantic actions themselves are complex but that <a href="http://spirit.sourceforge.net">
Spirit</a>
makes it easy to write the ensuing code, is reinforced when we come to consider
the <tt>func_def</tt> rule.</p>
<p>
Of the two &quot;globally visible&quot; semantic actions that are performed by
<tt>function_grammar</tt>, the first, adding a new function to the symbol table of
known functions, should be performed immediately after the <tt>func_decl</tt> rule
has finished. That means that the function name will then be available to the
<tt>expression_grammar</tt> variable that parses the function definition, enabling
recursive functions to be defined:</p>
<pre><code>
    # x is a double, so testing (x == 0) isn't very clever.
    factorial(x) = (x &lt; 0.1) ? 1 : x * factorial(x - 1) </code></pre><p>
Once again, <a href="http://spirit.sourceforge.net">
Spirit</a> makes the difficult seem easy:</p>
<pre><code>
    <span class="identifier">func_def
        </span><span class="special">=  </span><span class="identifier">func_decl
           </span><span class="special">[
               </span><span class="identifier">func_def</span><span class="special">.</span><span class="identifier">mangled_name </span><span class="special">= </span><span class="identifier">mangled_name</span><span class="special">(</span><span class="identifier">func_def</span><span class="special">.</span><span class="identifier">name</span><span class="special">,
                                                    </span><span class="identifier">size</span><span class="special">(</span><span class="identifier">func_def</span><span class="special">.</span><span class="identifier">args</span><span class="special">)),

               </span><span class="identifier">add_symbol</span><span class="special">(</span><span class="identifier">var</span><span class="special">(</span><span class="identifier">self</span><span class="special">.</span><span class="identifier">functions</span><span class="special">),
                          </span><span class="identifier">func_def</span><span class="special">.</span><span class="identifier">mangled_name</span><span class="special">,
                          </span><span class="identifier">construct_</span><span class="special">&lt;</span><span class="identifier">user_function</span><span class="special">&gt;(
                              </span><span class="identifier">func_def</span><span class="special">.</span><span class="identifier">name</span><span class="special">,
                              </span><span class="identifier">size</span><span class="special">(</span><span class="identifier">func_def</span><span class="special">.</span><span class="identifier">args</span><span class="special">))),
           </span><span class="special">]
           </span><span class="special">...
</span></code></pre>
<p>
Functions in the symbol table are accessed using a mangled version of their
name to allow functions with the same name but different arity to be
overloaded. The above code snippet uses yet another closure variable attached
to <tt>func_def</tt> to store this mangled name. Yup, you've guess it  &#8212;  the
<tt>mangled_name</tt> function, above, is a lazy function too. Finally, <tt>construct_</tt>
is used to create a wrapper for the <tt>user_function</tt> constructor. Ain't that
just nifty?</p>
<p>
We're almost ready to move on to the task of parsing the function
definition. Before we can do so, however, we must first create the
parser. Again, <a href="http://spirit.sourceforge.net">
Spirit</a> makes it easy. The fifth and final member of the
<tt>func_def</tt> closure is a pointer to an <tt>expression_grammar</tt> variable. Creating
the parser uses the <tt>new_</tt> lazy function wrapper for <tt>operator new</tt>:</p>
<pre><code>
    <span class="keyword">struct </span><span class="identifier">func_closure
        </span><span class="special">: </span><span class="identifier">spirit</span><span class="special">::</span><span class="identifier">closure</span><span class="special">&lt;</span><span class="identifier">func_closure</span><span class="special">,
                          </span><span class="special">...,
                          </span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">shared_ptr</span><span class="special">&lt;</span><span class="identifier">expression_grammar</span><span class="special">&gt; </span><span class="special">&gt;
    </span><span class="special">{
        </span><span class="identifier">member5 </span><span class="identifier">expr</span><span class="special">;
    </span><span class="special">};

    </span><span class="identifier">func_def
        </span><span class="special">=  </span><span class="identifier">func_decl
           </span><span class="special">[
               </span><span class="special">...
               </span><span class="comment">// Create the expression_grammar instance that will
               // parse the function definition.
               </span><span class="identifier">reset</span><span class="special">(</span><span class="identifier">func_def</span><span class="special">.</span><span class="identifier">expr</span><span class="special">,
                         </span><span class="identifier">new_</span><span class="special">&lt;</span><span class="identifier">expression_grammar</span><span class="special">&gt;(
                             </span><span class="identifier">var</span><span class="special">(</span><span class="identifier">self</span><span class="special">.</span><span class="identifier">functions</span><span class="special">),
                             </span><span class="identifier">var</span><span class="special">(</span><span class="identifier">self</span><span class="special">.</span><span class="identifier">global_vars</span><span class="special">),
                             </span><span class="special">*</span><span class="identifier">func_def</span><span class="special">.</span><span class="identifier">local_vars</span><span class="special">))
           </span><span class="special">]
           </span><span class="special">...
</span></code></pre>
<p>
Voilà! An expression_grammar parser that knows about the function's local
variables! The final step, parsing the function definition and adding a
<tt>func_def</tt> node to the <tt>stack</tt> that is 'returned' by <tt>function_grammar</tt>
should now be straightforward. First, we must wrap the dynamically created
<tt>expression_grammar</tt> variable up inside a <tt>lazy_p</tt> parser. Thereafter, we do
no more than <tt>stk.push_back(new func_def_node(/* constructor args
*/))</tt>. Lazily, of course:</p>
<pre><code>
    <span class="identifier">func_def
        </span><span class="special">=  </span><span class="identifier">func_decl
           </span><span class="special">[
               </span><span class="special">...
           </span><span class="special">]
        </span><span class="special">&gt;&gt; </span><span class="literal">'='
        </span><span class="special">&gt;&gt; </span><span class="identifier">lazy_p</span><span class="special">(*</span><span class="identifier">func_def</span><span class="special">.</span><span class="identifier">expr</span><span class="special">)
           </span><span class="special">[
               </span><span class="comment">// Add a node to the stack which will reset the
               // definition of the named function.

               // The func_def_node constructor:
               // func_def_node(shared_ptr&lt;function&gt;,
               //               user_func_expression const &amp;);
               </span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">self</span><span class="special">.</span><span class="identifier">stk</span><span class="special">,
                         </span><span class="identifier">new_</span><span class="special">&lt;</span><span class="identifier">func_def_node</span><span class="special">&gt;(
                             </span><span class="special">*</span><span class="identifier">find_symbol</span><span class="special">(</span><span class="identifier">var</span><span class="special">(</span><span class="identifier">self</span><span class="special">.</span><span class="identifier">functions</span><span class="special">),
                                          </span><span class="identifier">func_def</span><span class="special">.</span><span class="identifier">mangled_name</span><span class="special">),
                             </span><span class="identifier">construct_</span><span class="special">&lt;</span><span class="identifier">user_func_expression</span><span class="special">&gt;(
                                 </span><span class="identifier">func_def</span><span class="special">.</span><span class="identifier">args</span><span class="special">,
                                 </span><span class="identifier">func_def</span><span class="special">.</span><span class="identifier">local_vars</span><span class="special">,
                                 </span><span class="identifier">arg1</span><span class="special">)))
           </span><span class="special">]
        </span><span class="special">;
</span></code></pre>
<p>
<tt>func_def_node</tt>'s constructor takes two arguments. A pointer to the
appropriate function in the function symbol table and a <tt>user_func_expression</tt>
variable that contains the function definition. Note that <tt>arg1</tt>, above, is
the closure returned by the <tt>expression_grammar</tt> that parsed this definition.</p>
<p>
The actual code for <tt>function_grammar</tt> can be found
<a href="../src/yac_function_grammar.hpp">
here</a>. Once again, I won't try and
convince you that this has been an easy ride, but I think that <a href="http://spirit.sourceforge.net">
Spirit</a> and
Phoenix have made it straightforward to apply some pretty hairy logic to the
problem. Perhaps you think so too?</p>
<table style="margin-top: 10px;">
  <tr>
    <td><a href="../index.html"><img alt="TOP" src="theme/u_arr.gif"></img></a></td>
    <td><a href="variable_grammar.html"><img alt="PREVIOUS" src="theme/l_arr.gif"></img></a></td>
    <td><a href="expression_grammar.html"><img alt="NEXT" src="theme/r_arr.gif"></img></a></td>
   </tr>
</table>
<hr/>
<p>
  <a href="http://validator.w3.org/check/referer">
    <img style="border:0;width:88px;height:31px"
      src="theme/valid-xhtml11.png"
      alt="Valid XHTML 1.1!" />
  </a>
  <a href="http://jigsaw.w3.org/css-validator/check/referer">
    <img style="border:0;width:88px;height:31px"
      src="theme/vcss.png"
      alt="Valid CSS!" />
  </a>
</p>
<p class="copyright">

  Copyright &copy; 2004 Angus Leeming<br/><br/>
  Distributed under the Boost Software License,
  Version 1.0. (See accompanying file
  <a href="../LICENSE_1_0.txt">LICENSE_1_0.txt</a> or copy at
  <a href="http://www.boost.org/LICENSE_1_0.txt">
     http://www.boost.org/LICENSE_1_0.txt
  </a>)

</p>
</body>
</html>
