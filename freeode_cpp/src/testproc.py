#!/usr/bin/python

#------------------------------------------------------------------------------#
#                            Warning: Do not edit!                             #
#                                                                              #
# This file is generated, it will be overwritten every time the source file is #
# changed.                                                                     #
# Write a main routine in an other file and import this file. Or use execfile  #
# to load the objects defined here into the Python interpreter.                #
#------------------------------------------------------------------------------#
# Generated by Siml Version 0.1 on ????.??.?? ??:??                            #
#------------------------------------------------------------------------------#


from scipy import * # Also includes Numeric.
import Gnuplot, Gnuplot.funcutils


class TestProcedure:
    """ object to simulate procedure TestProcedure """

    def get(self, varName):
        """
        Get a variable by name.
        
        There are special variable names:
           'time': vector of times
           'all': array of all variables
        """
        if varName == 'time':
            return self.time
        elif varName == 'all':
            return self.resultArray
        index = self.resultArrayMap[varName]
        return self.resultArray[:,index]
        
    def graph(self, varNames):
        """
        Show one or several variables in a graph.
        
        Parameters:
           varNames: String with a list of variables to be plotted. (Space or comma seperated.)
                     e.g.: 'X mu' 
        """
        
        diagram=Gnuplot.Gnuplot(debug=0, persist=1)
        diagram('set data style lines')
        diagram.title(varNames)
        diagram.xlabel('Time')
        
        varList = varNames.replace(',', ' ').split(' ')
        for varName1 in varList:
            if not (varName1 in self.resultArrayMap): continue
            curve=Gnuplot.Data(self.get('time'), self.get(varName1))
            diagram.replot(curve)
        
    def __init__(self):
        #Assign values to the parameters (and create them)
        self.mu_max      = 0.32 #REAL
        self.Ks          = 0.1 #REAL
        self.Yxs         = 0.5 #REAL
        self.Ko          = 1e-3 #REAL
        self.Yxo         = 0.028 #REAL
        self.kla         = 360.0 #REAL
        self.O_star      = 0.21 #REAL

        #Set the initial values (of the state variables).
        self.y0 = zeros(3, Float)
        self.y0[0] = 0.2 # X
        self.y0[1] = 25 # S
        self.y0[2] = 0.21 # O

        #Map for converting variable names to indices or slices.
        self.resultArrayMap = {  'O':2,  'S':1,  'X':0,  'mu':3,  }

    def _diffStateT(self, y, time):
        """
        Compute the time derivatives of the state variables.
        This function will be called repeatedly by the integration algorithm.
        y: state vector,  time: current time
        """
        
        #Create local variables for the parameters.
        mu_max = self.mu_max
        Ks = self.Ks
        Yxs = self.Yxs
        Ko = self.Ko
        Yxo = self.Yxo
        kla = self.kla
        O_star = self.O_star

        #Dissect the state vector into individual, local state variables.
        X = y[0]
        S = y[1]
        O = y[2]

        #Create the return vector (the time derivatives dy/dt).
        y_t = zeros(3, Float)

        #Compute the algebraic variables.
        mu = mu_max * S/(S+Ks) * O/(O+Ko)
        #Compute the state variables. (Really the time derivatives.)
        y_t[0] = mu*X # = d X /dt 
        y_t[1] = -1/Yxs*mu*X # = d S /dt 
        y_t[2] = -1/Yxo*mu*X + kla*(O_star - O) # = d O /dt 

        return y_t

    def _outputEquations(self, y):
        """
        Compute (again) the algebraic variables as functions of the state 
        variables. All variables are then stored together in a 2D array.
        """
        
        #create the result array
        assert shape(y)[0] == size(self.time)
        sizeTime = shape(y)[0]
        self.resultArray = zeros((sizeTime, 4), Float)

        #copy the state variables into the result array
        numStates = shape(y)[1]
        self.resultArray[:,0:numStates] = y;

        #Create local variables for the parameters.
        mu_max = self.mu_max
        Ks = self.Ks
        Yxs = self.Yxs
        Ko = self.Ko
        Yxo = self.Yxo
        kla = self.kla
        O_star = self.O_star

        #Create local state variables - take them from the result array.
        X = self.resultArray[:,0]
        S = self.resultArray[:,1]
        O = self.resultArray[:,2]

        #Compute the algebraic variables.
        self.resultArray[:,3] = mu_max * S/(S+Ks) * O/(O+Ko) # mu

    def simulate(self):
        """
        This function performs the simulation.
        """
        
        self.time = linspace(0, 20, 100)
        y = integrate.odeint(self._diffStateT, self.y0, self.time)
        self._outputEquations(y)
        
