/***************************************************************************
 *   Copyright (C) 2005 by Eike Welk   *
 *   eike.welk@post.rwth-aachen.de   *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/
#include "siml_python_generator.h"
#include "config.h"

#include <boost/format.hpp>
#include <boost/tuple/tuple.hpp>

using std::string;
using std::endl;
using std::map;
using std::vector;
using boost::format;
using boost::tie;

/*!Construct and initialize the object, but do not generate codee.*/
siml::PyGenerator::PyGenerator(   boost::shared_ptr<CmCodeRepository> in_parse_result,
                                            std::ostream& in_py_file,
                                            std::ostream& in_err_file  ) :
        m_parse_result(in_parse_result),
        m_py_file(in_py_file),
        m_err_file(in_err_file),
        state_vector_size(0),
        result_array_colls(0)
{
}


siml::PyGenerator::~PyGenerator()
{
}


/*!
 Create python objects for all procedures in parse_result.
 */
void siml::PyGenerator::generate_all()
{
    gen_file_start();
    //loop over all procedures and generate a python object for each.
    ///@todo procedure list and procedure object in code model
    gen_procedure_object();
}


/*!
Generate the first few lines of the python file
 */
void siml::PyGenerator::gen_file_start()
{
    m_py_file <<
            "#!/usr/bin/python\n"
            "\n"
            "#------------------------------------------------------------------------------#\n"
            "#                            Warning: Do not edit!                             #\n"
            "#                                                                              #\n"
            "# This file is generated, it will be overwritten every time the source file is #\n"
            "# changed.                                                                     #\n"
            "# Write a main routine in an other file and import this file. Or use execfile  #\n"
            "# to load the objects defined here into the Python interpreter.                #\n"
            "#------------------------------------------------------------------------------#\n" <<
     format("# Generated by Siml Version %1% on ????.??.?? ??:??                      %|79t|#\n") % VERSION  <<
            "#------------------------------------------------------------------------------#\n"
            "\n"
            "\n"
            "from scipy import * # Also includes Numeric.\n"
            "import Gnuplot, Gnuplot.funcutils\n" ///@TODO change from Gnuplot to a more standard plotting library
            "\n"
            "\n"
            ;
}


/*!
Create a single procedure
 */
void siml::PyGenerator::gen_procedure_object()
{
    //collect parameters, variables and equations from all models and put them in big global tables
    ///@todo multi model capabilities and recursion into sub-models
    parameter = m_parse_result->model[0].parameter;
    variable = m_parse_result->model[0].variable;
    equation = m_parse_result->model[0].equation;

    ///@todo combine the parameters
    ///@todo create identifier names that are compatible with python

    //allocate space for each state variable in the state vector. Changes: state_vector_layout, state_vector_size
    layout_arrays();

    string procedure_name("TestProcedure");

    m_py_file << format("class %1%:") % procedure_name << endl;
//     m_py_file << format("    \"\"\" object to simulate procedure %1% \"\"\"") % procedure_name << endl;
    m_py_file << format("%|4t|\"\"\" object to simulate procedure %1% \"\"\"") % procedure_name << endl;
    m_py_file << endl;

    //Generate some infrastructure functions
    ///@todo these functions should later go into a common base class of all procedures
    gen_access_function();
    gen_graph_function();

    //Generate Constuctor which creates the parameters as member variables.
    gen_constructor();

    //Generate the function that contains the equations.
    gen_ODE_function();

    //Function to compute the algebraic variables after the simulation.
    gen_output_equations();

    //Generate the function that performs the simulation.
    gen_simulate_function();
}


/*!
Generate the __init__ function.
Generate Constuctor which creates the parameters as member variables
 */
void siml::PyGenerator::gen_constructor()
{
    m_py_file << format("%|4t|def __init__(self):") << endl;

    //Assign values to the parameters (and create them)
    m_py_file << format("%|8t|#Assign values to the parameters (and create them)") << endl;
    CmMemoryTable::const_iterator it;
    for( it = parameter.begin(); it != parameter.end(); ++it )
    {
        CmMemoryDescriptor paramD = *it;
        string pName = paramD.name;
        string pVal  = paramD.default_expr;
        string pType = paramD.type;
        m_py_file << format("%|8t|self.%1% %|25t|= %2% #%3%") % pName % pVal % pType << endl;
    }
    m_py_file << endl;

    //Set initial values of the state variables.
    m_py_file << format("%|8t|#Set the initial values (of the state variables).") << endl;
    m_py_file << format("%|8t|self.y0 = zeros(%1%, Float)") % state_vector_size << endl;
    CmMemoryTable::const_iterator itV;
    for( itV = variable.begin(); itV != variable.end(); ++itV )
    {
        CmMemoryDescriptor varD = *itV;
        if( varD.is_state_variable == false ) { continue; }

        string varName = varD.name;
        string index = state_vector_map[varName]; //look up variable's index in the state vector.
        string initExpression = varD.initial_expr;
        m_py_file << format("%|8t|self.y0[%1%] = %2% # %3%") % index % initExpression % varName << endl;
    }
    m_py_file << endl;

    //Map for converting variable names to indices or slices
    //necessary for later parameter access
    m_py_file << format("%|8t|#Map for converting variable names to indices or slices.") << endl;
    m_py_file << format("%|8t|self.resultArrayMap = { ");
    map<string, string>::const_iterator itMa;
    for( itMa = result_array_map.begin(); itMa != result_array_map.end(); ++itMa )
    {
        string varName, index;
        tie(varName, index) = *itMa;
        m_py_file << format(" '%1%':%2%, ") % varName % index;
    }
    m_py_file << " }" << endl << endl;

/*    m_py_file << format("%|8t|#List of diagrams.") << endl;
    m_py_file << format("%|8t|self.graphList = []") << endl;
    m_py_file << endl;*/
}


/*!
Generate the function that computes the time derivatives.
This function contains all equations. The function will be called repeatedly by
the simulation library routine.
 */
void siml::PyGenerator::gen_ODE_function()
{
    //y: state vector, time current time
    m_py_file <<
            "    def _diffStateT(self, y, time):\n"
            "        \"\"\"\n"
            "        Compute the time derivatives of the state variables.\n"
            "        This function will be called repeatedly by the integration algorithm.\n"
            "        y: state vector,  time: current time\n"
            "        \"\"\"\n"
            "        \n";

    //Create local variables for the parameters.
    m_py_file << format("%|8t|#Create local variables for the parameters.") << endl;
    CmMemoryTable::const_iterator itP;
    for( itP = parameter.begin(); itP != parameter.end(); ++itP )
    {
        CmMemoryDescriptor paramD = *itP;
        m_py_file << format("%|8t|%1% = self.%1%") % paramD.name << endl;
    }
    m_py_file << endl;

    //Dissect the state vector into individual, local state variables.
    m_py_file << format("%|8t|#Dissect the state vector into individual, local state variables.") << endl;
    CmMemoryTable::const_iterator itV;
    for( itV = variable.begin(); itV != variable.end(); ++itV )
    {
        CmMemoryDescriptor varD = *itV;
        if( varD.is_state_variable == false ) { continue; }

        string varName = varD.name;
        string index = state_vector_map[varName]; //look up variable's index in the state vector.
        m_py_file << format("%|8t|%1% = y[%2%]") % varName % index << endl;
    }
    m_py_file << endl;

    //Create the return vector
    m_py_file << format("%|8t|#Create the return vector (the time derivatives dy/dt).") << endl;
    m_py_file << format("%|8t|y_t = zeros(%1%, Float)") % state_vector_size << endl;
    m_py_file << endl;

    //write a line to compute each algebraic variable
    m_py_file << format("%|8t|#Compute the algebraic variables.") << endl;
    CmEquationTable::const_iterator itE;
    for( itE = equation.begin(); itE != equation.end(); ++itE )
    {
        CmEquationDescriptor equnD = *itE;
        if( equnD.is_ode_assignment ) { continue; }
        string algebVar = equnD.lhs;
        string mathExpr = equnD.rhs;
        m_py_file << format("%|8t|%1% = %2%") % algebVar % mathExpr << endl;
    }

    //write a line to compute the time derivative of each integrated variable
    m_py_file << format("%|8t|#Compute the state variables. (Really the time derivatives.)") << endl;
    for( itE = equation.begin(); itE != equation.end(); ++itE )
    {
        CmEquationDescriptor equnD = *itE;
        if( !equnD.is_ode_assignment ) { continue; }
        string stateVar = equnD.lhs;
        string mathExpr = equnD.rhs;
        string index = state_vector_map[stateVar]; //look up variable's index in state vector
        m_py_file << format("%|8t|y_t[%1%] = %2% # = d %3% /dt ") % index % mathExpr % stateVar << endl;
    }
    m_py_file << endl;

    //return the result
    m_py_file << format("%|8t|return y_t") << endl;
    m_py_file << endl;
}


/*!
Allocate space for each state variable in the state vector and result array.
The state variable have the same indices in both arrays.

The function changes:
state_vector_map, state_vector_ordering??, state_vector_size,
result_array_map, result_array_ordering??, result_array_colls.

The ...map variable are contain pairs (var_name, index) e.g: ("S", "1")
???The ...ordering variables contain the variable names in order of ascending index.???
state_vector_size is the state vector's number of rows.
result_array_colls is number of collumns in result array.
 */
void siml::PyGenerator::layout_arrays()
{
    state_vector_map.clear(); /*state_vector_ordering.clear();*/ state_vector_size=0;
    result_array_map.clear(); /*result_array_ordering.clear();*/ result_array_colls=0;

    //loop over all variables and assign indices for the state variables
    //each state variable gets a unique index in both arrays: state vector, result array.
    CmMemoryTable::const_iterator itV;
    uint currIndex=0;
    for( itV = variable.begin(); itV != variable.end(); ++itV )
    {
        CmMemoryDescriptor varD = *itV;
        if( varD.is_state_variable == false ) { continue; }

        string currIndexStr = (format("%1%") % currIndex).str(); //convert currIndex to currIndexStr
        state_vector_map[varD.name] = currIndexStr;
        result_array_map[varD.name] = currIndexStr;
/*        state_vector_ordering.push_back(varD.name);
        result_array_ordering.push_back(varD.name);*/
        ++currIndex;
    }
    state_vector_size = currIndex;

    //Loop over all variables again and assign indices for the algebraic variables.
    //Each algebraic variable gets a unique index in the result array.
    for( itV = variable.begin(); itV != variable.end(); ++itV )
    {
        CmMemoryDescriptor varD = *itV;
        if( varD.is_state_variable == true ) { continue; }

        string currIndexStr = (format("%1%") % currIndex).str(); //convert currIndex to currIndexStr
        result_array_map[varD.name] = currIndexStr;
/*        result_array_ordering.push_back(varD.name);*/
        ++currIndex;
    }
    result_array_colls = currIndex;
}


/*!
Generate a function that computes the algebraic variables again after the simulation,
so they can be examined too. Only state variables are stored doring ODE simulation.
*/
void siml::PyGenerator::gen_output_equations()
{
    m_py_file <<
            "    def _outputEquations(self, y):\n"
            "        \"\"\"\n"
            "        Compute (again) the algebraic variables as functions of the state \n"
            "        variables. All variables are then stored together in a 2D array.\n"
            "        \"\"\"\n"
            "        \n";

    //create the result array
    m_py_file << format("%|8t|#create the result array") << endl;
    m_py_file << format("%|8t|assert shape(y)[0] == size(self.time)") << endl;
    m_py_file << format("%|8t|sizeTime = shape(y)[0]") << endl;
    m_py_file << format("%|8t|self.resultArray = zeros((sizeTime, %1%), Float)") % result_array_colls << endl;
    m_py_file << endl;

    //copy the state variables into the result array
    m_py_file << format("%|8t|#copy the state variables into the result array") << endl;
    m_py_file << format("%|8t|numStates = shape(y)[1]") << endl;
    m_py_file << format("%|8t|self.resultArray[:,0:numStates] = y;") << endl;
    m_py_file << endl;

    //Create local variables for the parameters.
    m_py_file << format("%|8t|#Create local variables for the parameters.") << endl;
    CmMemoryTable::const_iterator itP;
    for( itP = parameter.begin(); itP != parameter.end(); ++itP )
    {
        CmMemoryDescriptor paramD = *itP;
        m_py_file << format("%|8t|%1% = self.%1%") % paramD.name << endl;
    }
    m_py_file << endl;

    //Create local state variables - take them from the result array.
    m_py_file << format("%|8t|#Create local state variables - take them from the result array.") << endl;
    CmMemoryTable::const_iterator itV;
    for( itV = variable.begin(); itV != variable.end(); ++itV )
    {
        CmMemoryDescriptor varD = *itV;
        if( varD.is_state_variable == false ) { continue; }

        string varName = varD.name;
        string index = result_array_map[varName]; //look up variable's index
        m_py_file << format("%|8t|%1% = self.resultArray[:,%2%]") % varName % index << endl;
    }
    m_py_file << endl;

    //compute the algebraic variables
    m_py_file << format("%|8t|#Compute the algebraic variables.") << endl;
    CmEquationTable::const_iterator itE;
    for( itE = equation.begin(); itE != equation.end(); ++itE )
    {
        CmEquationDescriptor equnD = *itE;
        if( equnD.is_ode_assignment ) { continue; }

        string algebVar = equnD.lhs;
        string index = result_array_map[algebVar];
        string mathExpr = equnD.rhs;
        m_py_file << format("%|8t|self.resultArray[:,%1%] = %2% # %3%") % index % mathExpr % algebVar << endl;
    }

    m_py_file << endl;
}


/*!
Generate the function that will perform the simulation.
*/
void siml::PyGenerator::gen_simulate_function()
{
    m_py_file <<
            "    def simulate(self):\n"
            "        \"\"\"\n"
            "        This function performs the simulation.\n"
            "        \"\"\"\n"
            "        \n"
            "        self.time = linspace(0, 20, 100)\n" ///@todo respect SOLUTIONPARAMETERS
            "        y = integrate.odeint(self._diffStateT, self.y0, self.time)\n"
            "        self._outputEquations(y)\n"
            "        \n";
}



/*!
Access variables by name.
@todo add returning multiple variables at once
*/
void siml::PyGenerator::gen_access_function()
{
    m_py_file <<
            "    def get(self, varName):\n"
            "        \"\"\"\n"
            "        Get a variable by name.\n"
            "        \n"
            "        There are special variable names:\n"
            "           'time': vector of times\n"
            "           'all': array of all variables\n"
            "        \"\"\"\n"
            "        if varName == 'time':\n"
            "            return self.time\n"
            "        elif varName == 'all':\n"
            "            return self.resultArray\n"
            "        index = self.resultArrayMap[varName]\n"
            "        return self.resultArray[:,index]\n"
            "        \n";
}


/*!
Display graphs
*/
void siml::PyGenerator::gen_graph_function()
{
    m_py_file <<
            "    def graph(self, varNames):\n"
            "        \"\"\"\n"
            "        Show one or several variables in a graph.\n"
            "        \n"
            "        Parameters:\n"
            "           varNames: String with a list of variables to be plotted. (Space or comma seperated.)\n"
            "                     e.g.: 'X mu' \n"
            "        \"\"\"\n"
            "        \n"
            "        diagram=Gnuplot.Gnuplot(debug=0, persist=1)\n"
            "        diagram('set data style lines')\n"
            "        diagram.title(varNames)\n"
            "        diagram.xlabel('Time')\n"
            "        \n"
            "        varList = varNames.replace(',', ' ').split(' ')\n"
            "        for varName1 in varList:\n"
            "            if not (varName1 in self.resultArrayMap): continue\n"
            "            curve=Gnuplot.Data(self.get('time'), self.get(varName1))\n"
            "            diagram.replot(curve)\n"
            "        \n";
}
